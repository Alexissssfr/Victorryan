<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Victorryan</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        margin-top: 20px;
      }
      .hidden {
        display: none;
      }
      button {
        padding: 8px 16px;
        background-color: #4caf50;
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 4px;
        margin: 5px;
      }
      button:hover {
        background-color: #45a049;
      }
      input {
        padding: 8px;
        margin-bottom: 10px;
        width: 100%;
        border-radius: 4px;
        border: 1px solid #ddd;
      }
      .game-id {
        background-color: #f1f1f1;
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      /* Styles pour les cartes */
      .cards-container {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 15px;
        justify-content: center;
      }

      .card {
        width: auto;
        min-width: 180px;
        max-width: 190px;
        height: auto;
        min-height: 280px;
        max-height: 300px;
        border-radius: 10px;
        padding: 0;
        margin: 0 8px 15px 8px;
        background-color: transparent;
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
        cursor: pointer;
        position: relative;
        overflow: visible;
        display: inline-block;
      }

      .card:hover {
        transform: translateY(-8px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
      }

      .card-image {
        width: 100%;
        height: 100%;
        background-size: 100% 100%;
        background-position: center;
        background-repeat: no-repeat;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1;
        border-radius: 10px;
      }

      .card-title {
        display: none;
      }

      .card-stats {
        position: absolute;
        top: 5px;
        left: 5px;
        right: 5px;
        z-index: 3;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        background: none;
        margin: 0;
        padding: 0;
      }

      .card-overlay {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: transparent;
        padding: 0;
        border-top: none;
        backdrop-filter: none;
        z-index: 2;
      }

      .personnage-card {
        background-color: #e8f5e9;
      }

      .bonus-card {
        background-color: #e3f2fd;
      }

      .opponent-card {
        background-color: #fff3e0;
      }

      .player-section {
        background-color: white;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .game-status {
        background-color: #333;
        color: white;
        padding: 10px;
        text-align: center;
        border-radius: 4px;
        margin-bottom: 20px;
      }

      .actions {
        display: flex;
        justify-content: center;
        margin-top: 20px;
      }

      .active-bonus-indicator {
        position: absolute;
        top: 5px;
        right: 5px;
        background-color: rgba(255, 152, 0, 0.8);
        color: white;
        border-radius: 50%;
        width: 26px;
        height: 26px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
        z-index: 5;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .game-info {
        background-color: #f1f1f1;
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
      }

      .turn-indicator {
        font-weight: bold;
        color: #4caf50;
      }

      /* Ajouter une classe pour agrandir la carte au survol */
      .card-zoom {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(2) !important;
        z-index: 1000;
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.5) !important;
      }

      /* Ajoutez un fond semi-transparent quand une carte est zoomée */
      .overlay-background {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 999;
      }

      .card.depleted {
        opacity: 0.6;
        filter: grayscale(70%);
      }

      .card.cannot-attack {
        opacity: 0.7;
        background-color: #ffebee;
        border: 2px solid #ffcdd2;
        position: relative;
      }

      .card.cannot-attack::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
          45deg,
          rgba(244, 67, 54, 0.1),
          rgba(244, 67, 54, 0.1) 10px,
          rgba(244, 67, 54, 0.2) 10px,
          rgba(244, 67, 54, 0.2) 20px
        );
        border-radius: 12px;
        pointer-events: none;
        z-index: 2;
      }

      .card.can-attack {
        border: 3px solid #4caf50;
        box-shadow: 0 0 12px rgba(76, 175, 80, 0.8);
      }

      .card.can-target {
        border: 3px solid #f44336;
        box-shadow: 0 0 12px rgba(244, 67, 54, 0.8);
      }

      .turn-info {
        background-color: #333;
        color: white;
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .turn-number {
        font-weight: bold;
        color: #4caf50;
        background-color: rgba(255, 255, 255, 0.1);
        padding: 5px 10px;
        border-radius: 4px;
        margin-left: 10px;
      }

      .attack-status {
        background-color: #ff9800;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        display: inline-block;
        margin-left: 10px;
      }

      .turn-change-notification {
        position: fixed;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        padding: 30px 50px;
        background-color: rgba(76, 175, 80, 0.9);
        color: white;
        border-radius: 8px;
        font-weight: bold;
        font-size: 24px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        transition: opacity 0.5s;
      }

      /* Amélioration des états visuels des cartes */
      .card.selected {
        transform: translateY(-12px);
        border: 3px solid #ffd700;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.7),
          inset 0 0 10px rgba(255, 215, 0, 0.3);
        animation: selectedPulse 2s infinite;
      }

      @keyframes selectedPulse {
        0% {
          box-shadow: 0 0 20px rgba(255, 215, 0, 0.7),
            inset 0 0 10px rgba(255, 215, 0, 0.3);
        }
        50% {
          box-shadow: 0 0 30px rgba(255, 215, 0, 0.9),
            inset 0 0 15px rgba(255, 215, 0, 0.5);
        }
        100% {
          box-shadow: 0 0 20px rgba(255, 215, 0, 0.7),
            inset 0 0 10px rgba(255, 215, 0, 0.3);
        }
      }

      .card.selected .card-image {
        filter: brightness(120%) contrast(110%);
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
        }
        50% {
          box-shadow: 0 0 25px rgba(76, 175, 80, 0.9);
        }
        100% {
          box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
        }
      }

      /* Styles pour l'écran de fin de partie */
      .game-over-container {
        background-color: rgba(255, 255, 255, 0.95);
        border-radius: 15px;
        padding: 40px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        max-width: 700px;
        margin: 0 auto;
        text-align: center;
        backdrop-filter: blur(5px);
        animation: fadeIn 0.6s ease-out, floatUp 0.8s ease-out;
      }

      @keyframes floatUp {
        from {
          transform: translateY(30px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      #gameOverTitle {
        font-size: 42px;
        margin-bottom: 20px;
        color: #333;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      }

      #gameOverMessage {
        font-size: 20px;
        margin-bottom: 30px;
        padding: 20px;
        border-radius: 10px;
      }

      .message-victory {
        background-color: #e8f5e9;
        border-left: 5px solid #4caf50;
        color: #2e7d32;
      }

      .message-defeat {
        background-color: #ffebee;
        border-left: 5px solid #f44336;
        color: #c62828;
      }

      .message-tie {
        background-color: #e3f2fd;
        border-left: 5px solid #2196f3;
        color: #1565c0;
      }

      .stats-container {
        background-color: rgba(245, 245, 245, 0.9);
        border-radius: 12px;
        padding: 25px;
        margin-bottom: 40px;
      }

      .player-stat {
        display: flex;
        justify-content: space-between;
        margin-bottom: 15px;
        padding: 15px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
      }

      .player-stat:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      }

      .player-stat.winner {
        background-color: rgba(232, 245, 233, 0.9);
        font-weight: bold;
        border-left: 5px solid #4caf50;
      }

      .game-over-actions {
        display: flex;
        justify-content: center;
        gap: 30px;
        margin-top: 30px;
      }

      .btn {
        padding: 15px 30px;
        font-size: 18px;
        border-radius: 30px;
        cursor: pointer;
        transition: all 0.3s;
        border: none;
        font-weight: bold;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 7px 14px rgba(0, 0, 0, 0.15);
      }

      .btn:active {
        transform: translateY(1px);
      }

      #newGameBtn {
        background-color: #4caf50;
        color: white;
      }

      #newGameBtn:hover {
        background-color: #3d8b40;
      }

      .btn-secondary {
        background-color: #f5f5f5;
        color: #333;
      }

      .btn-secondary:hover {
        background-color: #e0e0e0;
      }

      /* S'assurer que l'écran de fin est bien visible */
      #gameOverScreen {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      #gameOverScreen.hidden {
        display: none;
      }

      /* Style simplifié pour les statistiques */
      .stat-item {
        display: inline-flex;
        align-items: center;
        margin: 3px;
        padding: 3px 8px;
        border-radius: 10px;
        font-weight: bold;
        font-size: 14px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      }

      .stat-hp {
        border-left: none;
        color: white;
      }

      .stat-hp::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        margin-right: 4px;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="red" d="M47.6 300.4L228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6 0 115.2 0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"/></svg>');
        background-repeat: no-repeat;
        background-position: center;
        background-size: contain;
      }

      .stat-attack {
        border-left: none;
        color: white;
      }

      .stat-attack::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        margin-right: 4px;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="lightblue" d="M320 146c12.9 0 24.8 3.9 34.8 10.4 10.8 7.1 19.4 17.2 24.8 29.5 6.5 15 5.8 28.1 3.8 36.9-2.3 10.2-7.5 17.5-11.8 22.8-5.2 6.4-11.6 12-18.7 16.6-2.8 1.8-5.7 3.5-8.7 5-4.5 2.3-9.2 4.2-14 5.7L313 401.2c-1.7 10.1-10.4 17.5-20.8 17.5-5.4 0-10.4-2-14.2-5.4-3.5-3.2-5.9-7.5-6.5-12.3l-10.4-84.9-5.2 .7c-10 1.3-19.6-5.9-21.6-15.7l-7.1-35.5c-1.9-9.6 4.1-18.9 13.5-21.5l46.2-12.6-22-6.1c-9.1-2.5-15.1-10.9-14.5-19.9 .6-9.2 7.5-16.7 16.3-19h.3l14.6-3.5L299.8 172c-10.1-2-16.7-11.6-15-21.4 1.3-8 7.3-14.3 14.9-16.2 .7-.2 1.5-.3 2.3-.4h13.7 4.3zm-83.8 198L233 381.7c-3 35.4-32.9 62.3-68.5 62.3-22.1 0-41.8-10.5-54.3-26.7L32.7 323.9C11.4 296.3 .3 262.4 3.1 228.2S22.6 164.8 49.2 142c13.3-11.4 31.4-14.9 47.8-9.1 14.2 5 25.2 16.2 30 30.4l9 27.1c3.3 9.8 13.9 15.2 23.7 11.9s15.1-13.9 11.9-23.7l-9-27.1c-8.6-25.8-27.6-45.5-51.8-54.9-25.3-9.8-53.1-6.7-75.9 8.4l-1.1 .7c-36.3 31-59.2 75.7-63.7 124.8s10.3 97.8 40.2 138.1l77.5 93.5c21.4 25.8 53.2 40.8 87.2 40.8 59.5 0 108.2-45.3 113.9-103.7l5.8-59.1-18.8-1.1c-10.5-.6-18.5-9.5-18-20zm276-25.6L444.1 351c-18.3 14.2-40.2 21.4-62.2 21.1-21.6-.3-40.6-7.8-53.3-21.6l-5.7-6.2c-7.1-7.7-6.6-19.8 1.2-26.9s19.8-6.6 26.9 1.2l5.7 6.2c6.9 7.5 16.9 11.2 29.2 11.4 12.5 .2 25.4-3.6 35.7-11.6l68.6-53.1-11.7-15-69.8 54.1c-.2 .2-.4 .3-.5 .5-2.5 2.5-5.9 3.8-9.3 3.7-3.1-.1-6.2-1.5-8.4-3.8l-58.7-63.7c-5.5-5.9-11.8-8.5-16.1-9.5l7.4 35.2 118.9-15.9c5.9-.8 11.8 1.1 16.4 5.1s7.1 9.9 7.1 16v13.4c0 8.4-5.5 15.9-13.6 18.4zM445.8 266.7c-11.5 1.5-21.4-6.5-22.9-18s6.5-21.4 18-22.9l58.1-7.8c6.1-.8 11.3 1.3 14.9 5.3s5.2 9.5 4.3 14.4c-1.5 8.4-7.8 14.5-16.1 15.6l-56.3 13.4z"/></svg>');
        background-repeat: no-repeat;
        background-position: center;
        background-size: contain;
      }

      .stat-turns {
        border-left: none;
        color: white;
      }

      .stat-turns::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        margin-right: 4px;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="lightgreen" d="M464 256A208 208 0 1 1 48 256a208 208 0 1 1 416 0zM0 256a256 256 0 1 0 512 0A256 256 0 1 0 0 256zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/></svg>');
        background-repeat: no-repeat;
        background-position: center;
        background-size: contain;
      }

      .stat-bonus {
        border-left: none;
        color: white;
      }

      .stat-bonus::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        margin-right: 4px;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="orange" d="M400 0H176c-26.5 0-48.1 21.8-47.1 48.2c.2 5.3 .4 10.6 .7 15.8H24C10.7 64 0 74.7 0 88c0 92.6 33.5 157 78.5 200.7c44.3 43.1 98.3 64.8 138.1 75.8c23.4 6.5 39.4 26 39.4 45.6c0 20.9-17 37.9-37.9 37.9H192c-17.7 0-32 14.3-32 32s14.3 32 32 32H384c17.7 0 32-14.3 32-32s-14.3-32-32-32H357.9C337 448 320 431 320 410.1c0-19.6 15.9-39.2 39.4-45.6c39.9-11 93.9-32.7 138.2-75.8C542.5 245 576 180.6 576 88c0-13.3-10.7-24-24-24H446.4c.3-5.2 .5-10.4 .7-15.8C448.1 21.8 426.5 0 400 0zM48.9 112h84.4c9.1 90.1 29.2 150.3 51.9 190.6c-24.9-11-50.8-26.5-73.2-48.3c-32-31.1-58-76-63-142.3zM464.1 254.3c-22.4 21.8-48.3 37.3-73.2 48.3c22.7-40.3 42.8-100.5 51.9-190.6h84.4c-5.1 66.3-31.1 111.2-63 142.3z"/></svg>');
        background-repeat: no-repeat;
        background-position: center;
        background-size: contain;
      }

      /* Style pour les statuts de santé */
      .health-depleted {
        color: #ff5252;
        font-weight: bold;
        text-decoration: line-through;
      }

      .health-critical {
        color: #ff5252;
        font-weight: bold;
      }

      .health-warning {
        color: #ffb74d;
      }

      .health-normal {
        color: #81c784;
      }

      /* Style pour les cartes épuisées */
      .card.depleted .card-image {
        filter: grayscale(70%) brightness(70%);
      }

      /* Boutons d'action flottants */
      .action-buttons {
        position: fixed;
        bottom: 30px;
        left: 0;
        right: 0;
        display: flex;
        justify-content: center;
        gap: 15px;
        z-index: 1000;
        padding: 15px;
        background-color: rgba(51, 51, 51, 0.8);
        border-radius: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        margin: 0 auto;
        max-width: 600px;
        backdrop-filter: blur(5px);
        transition: transform 0.3s, opacity 0.3s;
      }

      .action-buttons.hidden {
        transform: translateY(100px);
        opacity: 0;
        pointer-events: none;
      }

      .action-button {
        padding: 12px 20px;
        border-radius: 30px;
        border: none;
        font-weight: bold;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        min-width: 120px;
      }

      .action-button:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
      }

      .action-button:active {
        transform: translateY(1px);
      }

      .attack-button {
        background-color: #f44336;
        color: white;
      }

      .bonus-button {
        background-color: #ff9800;
        color: white;
      }
    </style>
  </head>
  <body>
    <h1>Victorryan - Jeu de cartes</h1>

    <!-- Écran initial -->
    <div id="homeScreen">
      <button id="createGameBtn">Créer une partie</button>
      <hr />
      <div>
        <h3>Rejoindre une partie</h3>
        <input type="text" id="playerNameInput" placeholder="Votre nom" />
        <input type="text" id="gameIdInput" placeholder="ID de la partie" />
        <button id="joinGameBtn">Rejoindre</button>
      </div>
    </div>

    <!-- Écran de création de partie -->
    <div id="createdGameScreen" class="hidden">
      <h2>Partie créée!</h2>
      <p>Partagez cet ID avec votre adversaire:</p>
      <div class="game-id">
        <span id="gameIdDisplay"></span>
        <button id="copyGameIdBtn">Copier</button>
      </div>
      <div>
        <input type="text" id="creatorNameInput" placeholder="Votre nom" />
        <button id="joinAsCreatorBtn">Rejoindre en tant que créateur</button>
      </div>
    </div>

    <!-- Écran d'attente -->
    <div id="waitingScreen" class="hidden">
      <h2>En attente...</h2>
      <p id="waitingMessage">En attente d'un adversaire</p>
    </div>

    <!-- Écran de jeu -->
    <div id="gameScreen" class="hidden">
      <div class="game-status" id="gameStatus">En attente...</div>

      <div class="game-info">
        <h3>Informations de la partie</h3>
        <div id="gameInfo">
          <p>
            Votre tour:
            <span id="turnIndicator" class="turn-indicator">En attente...</span>
          </p>
          <p>Joueur 1: <span id="player1Name"></span></p>
          <p>Joueur 2: <span id="player2Name"></span></p>
        </div>
      </div>

      <div class="player-section">
        <h3>Vos personnages</h3>
        <div class="cards-container" id="yourCharacters"></div>
      </div>

      <div class="player-section">
        <h3>Vos bonus</h3>
        <div class="cards-container" id="yourBonus"></div>
      </div>

      <div class="player-section">
        <h3>Personnages adverses</h3>
        <div class="cards-container" id="opponentCharacters"></div>
      </div>

      <div class="action-buttons hidden" id="actionButtons">
        <button id="attackBtn" class="action-button attack-button">
          <svg width="16" height="16" viewBox="0 0 512 512" fill="currentColor">
            <path
              d="M320 146c12.9 0 24.8 3.9 34.8 10.4 10.8 7.1 19.4 17.2 24.8 29.5 6.5 15 5.8 28.1 3.8 36.9-2.3 10.2-7.5 17.5-11.8 22.8-5.2 6.4-11.6 12-18.7 16.6-2.8 1.8-5.7 3.5-8.7 5-4.5 2.3-9.2 4.2-14 5.7L313 401.2c-1.7 10.1-10.4 17.5-20.8 17.5-5.4 0-10.4-2-14.2-5.4-3.5-3.2-5.9-7.5-6.5-12.3l-10.4-84.9-5.2 .7c-10 1.3-19.6-5.9-21.6-15.7l-7.1-35.5c-1.9-9.6 4.1-18.9 13.5-21.5l46.2-12.6-22-6.1c-9.1-2.5-15.1-10.9-14.5-19.9 .6-9.2 7.5-16.7 16.3-19h.3l14.6-3.5L299.8 172c-10.1-2-16.7-11.6-15-21.4 1.3-8 7.3-14.3 14.9-16.2 .7-.2 1.5-.3 2.3-.4h13.7 4.3zm-83.8 198L233 381.7c-3 35.4-32.9 62.3-68.5 62.3-22.1 0-41.8-10.5-54.3-26.7L32.7 323.9C11.4 296.3 .3 262.4 3.1 228.2S22.6 164.8 49.2 142c13.3-11.4 31.4-14.9 47.8-9.1 14.2 5 25.2 16.2 30 30.4l9 27.1c3.3 9.8 13.9 15.2 23.7 11.9s15.1-13.9 11.9-23.7l-9-27.1c-8.6-25.8-27.6-45.5-51.8-54.9-25.3-9.8-53.1-6.7-75.9 8.4l-1.1 .7c-36.3 31-59.2 75.7-63.7 124.8s10.3 97.8 40.2 138.1l77.5 93.5c21.4 25.8 53.2 40.8 87.2 40.8 59.5 0 108.2-45.3 113.9-103.7l5.8-59.1-18.8-1.1c-10.5-.6-18.5-9.5-18-20zm276-25.6L444.1 351c-18.3 14.2-40.2 21.4-62.2 21.1-21.6-.3-40.6-7.8-53.3-21.6l-5.7-6.2c-7.1-7.7-6.6-19.8 1.2-26.9s19.8-6.6 26.9 1.2l5.7 6.2c6.9 7.5 16.9 11.2 29.2 11.4 12.5 .2 25.4-3.6 35.7-11.6l68.6-53.1-11.7-15-69.8 54.1c-.2 .2-.4 .3-.5 .5-2.5 2.5-5.9 3.8-9.3 3.7-3.1-.1-6.2-1.5-8.4-3.8l-58.7-63.7c-5.5-5.9-11.8-8.5-16.1-9.5l7.4 35.2 118.9-15.9c5.9-.8 11.8 1.1 16.4 5.1s7.1 9.9 7.1 16v13.4c0 8.4-5.5 15.9-13.6 18.4zM445.8 266.7c-11.5 1.5-21.4-6.5-22.9-18s6.5-21.4 18-22.9l58.1-7.8c6.1-.8 11.3 1.3 14.9 5.3s5.2 9.5 4.3 14.4c-1.5 8.4-7.8 14.5-16.1 15.6l-56.3 13.4z"
            />
          </svg>
          Attaquer
        </button>
        <button id="playBonusBtn" class="action-button bonus-button">
          <svg width="16" height="16" viewBox="0 0 576 512" fill="currentColor">
            <path
              d="M400 0H176c-26.5 0-48.1 21.8-47.1 48.2c.2 5.3 .4 10.6 .7 15.8H24C10.7 64 0 74.7 0 88c0 92.6 33.5 157 78.5 200.7c44.3 43.1 98.3 64.8 138.1 75.8c23.4 6.5 39.4 26 39.4 45.6c0 20.9-17 37.9-37.9 37.9H192c-17.7 0-32 14.3-32 32s14.3 32 32 32H384c17.7 0 32-14.3 32-32s-14.3-32-32-32H357.9C337 448 320 431 320 410.1c0-19.6 15.9-39.2 39.4-45.6c39.9-11 93.9-32.7 138.2-75.8C542.5 245 576 180.6 576 88c0-13.3-10.7-24-24-24H446.4c.3-5.2 .5-10.4 .7-15.8C448.1 21.8 426.5 0 400 0zM48.9 112h84.4c9.1 90.1 29.2 150.3 51.9 190.6c-24.9-11-50.8-26.5-73.2-48.3c-32-31.1-58-76-63-142.3zM464.1 254.3c-22.4 21.8-48.3 37.3-73.2 48.3c22.7-40.3 42.8-100.5 51.9-190.6h84.4c-5.1 66.3-31.1 111.2-63 142.3z"
            />
          </svg>
          Jouer bonus
        </button>
      </div>
    </div>

    <!-- Écran de fin de partie -->
    <div id="gameOverScreen" class="hidden">
      <div class="game-over-container">
        <h2 id="gameOverTitle">Partie terminée</h2>
        <div id="gameOverMessage"></div>

        <div class="stats-container">
          <h3>Statistiques de la partie</h3>
          <div id="playerStats"></div>
        </div>

        <div class="game-over-actions">
          <button id="newGameBtn" class="btn">Nouvelle partie</button>
          <button id="quitGameBtn" class="btn btn-secondary">
            Retour au menu
          </button>
        </div>
      </div>
    </div>

    <div id="messages"></div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // DOM Elements
        const screens = {
          home: document.getElementById("homeScreen"),
          created: document.getElementById("createdGameScreen"),
          waiting: document.getElementById("waitingScreen"),
          game: document.getElementById("gameScreen"),
        };

        const createGameBtn = document.getElementById("createGameBtn");
        const joinGameBtn = document.getElementById("joinGameBtn");
        const joinAsCreatorBtn = document.getElementById("joinAsCreatorBtn");
        const gameIdDisplay = document.getElementById("gameIdDisplay");
        const copyGameIdBtn = document.getElementById("copyGameIdBtn");
        const gameStatus = document.getElementById("gameStatus");
        const attackBtn = document.getElementById("attackBtn");
        const playBonusBtn = document.getElementById("playBonusBtn");
        const messages = document.getElementById("messages");

        // DOM Elements pour les cartes
        const yourCharacters = document.getElementById("yourCharacters");
        const yourBonus = document.getElementById("yourBonus");
        const opponentCharacters =
          document.getElementById("opponentCharacters");

        // Game State
        let gameState = {
          gameId: null,
          playerId: null,
          playerName: null,
          isMyTurn: false,
          gameData: null,
          selectedCharacter: null,
          selectedBonus: null,
          targetCharacter: null,
          bonusPlayedThisTurn: false,
          lastBonusTarget: null,
        };

        // Socket.io
        const socket = io();

        // Ajoutez ces variables DOM au début de votre code JavaScript
        const gameOverScreen = document.getElementById("gameOverScreen");
        const gameOverTitle = document.getElementById("gameOverTitle");
        const gameOverMessage = document.getElementById("gameOverMessage");
        const playerStats = document.getElementById("playerStats");
        const newGameBtn = document.getElementById("newGameBtn");
        const quitGameBtn = document.getElementById("quitGameBtn");

        // Functions
        function showScreen(screenName) {
          Object.keys(screens).forEach((key) => {
            screens[key].classList.add("hidden");
          });
          screens[screenName].classList.remove("hidden");
        }

        function showMessage(text, isError = false) {
          const p = document.createElement("p");
          p.textContent = text;
          if (isError) p.style.color = "red";
          messages.appendChild(p);
          messages.scrollTop = messages.scrollHeight;
        }

        // Ajouter cette fonction pour vérifier si le joueur courant peut jouer
        function currentPlayerCanPlay() {
          if (!gameState.gameData || !gameState.isMyTurn) return false;

          const player = gameState.gameData.players[gameState.playerId];
          if (!player) return false;

          // Vérifier si au moins un personnage est vivant et a des tours d'attaque
          return Object.values(player.charactersState).some(
            (char) => char.currentHealth > 0 && char.currentTurns > 0
          );
        }

        // Fonction pour afficher les cartes des joueurs
        function renderCards() {
          if (!gameState.gameData) return;

          const game = gameState.gameData;
          const player = game.players[gameState.playerId];

          if (!player || !player.cards) {
            console.log("Données du joueur non disponibles");
            return;
          }

          // Si c'est notre tour mais qu'on ne peut pas jouer, passer le tour automatiquement
          if (
            gameState.isMyTurn &&
            !currentPlayerCanPlay() &&
            !game.attackPerformed
          ) {
            // Trouver l'adversaire
            let opponent = null;
            for (const id in game.players) {
              if (id !== gameState.playerId) {
                opponent = game.players[id];
                break;
              }
            }

            // Vérifier si l'adversaire peut jouer
            const opponentCanPlay =
              opponent &&
              Object.values(opponent.charactersState).some(
                (char) => char.currentHealth > 0 && char.currentTurns > 0
              );

            if (opponentCanPlay) {
              // Si l'adversaire peut jouer, passer le tour
              showMessage(
                "Vous ne pouvez plus attaquer avec aucun personnage. Passage de tour automatique."
              );

              socket.emit("endTurn", {
                gameId: gameState.gameId,
                playerId: gameState.playerId,
              });

              // Pour éviter des émissions multiples
              game.attackPerformed = true;
            } else {
              // Si personne ne peut jouer, fin de partie
              checkGameOver();
            }
          }

          // Si nous sommes en train d'attendre que l'attaque soit traitée, désactiver toutes les interactions
          const attackInProgress = gameState.isMyTurn && game.attackPerformed;

          // Trouver l'adversaire
          let opponent = null;
          for (const id in game.players) {
            if (id !== gameState.playerId) {
              opponent = game.players[id];
              break;
            }
          }

          // Afficher vos cartes personnages
          yourCharacters.innerHTML = "";
          if (player.cards.personnages) {
            player.cards.personnages.forEach((card) => {
              const characterState = player.charactersState[card.id];
              const cardEl = createCharacterCard(card, characterState, false);

              // Simplification de la condition pour ajouter l'événement de clic
              // C'est mon tour ET le personnage est vivant ET il a des tours d'attaque ET je n'ai pas encore attaqué
              const canAttack =
                gameState.isMyTurn &&
                characterState &&
                characterState.currentHealth > 0 &&
                characterState.currentTurns > 0 &&
                !game.attackPerformed;

              if (canAttack) {
                cardEl.addEventListener("click", () =>
                  selectYourCharacter(card.id)
                );
                cardEl.classList.add("can-attack");
              } else if (
                characterState &&
                (characterState.currentHealth <= 0 ||
                  characterState.currentTurns <= 0)
              ) {
                cardEl.classList.add("cannot-attack");
              }

              if (card.id === gameState.selectedCharacter) {
                cardEl.classList.add("selected");
              }

              yourCharacters.appendChild(cardEl);
            });
          }

          // Afficher vos cartes bonus
          yourBonus.innerHTML = "";
          player.cards.bonus.forEach((card) => {
            const cardEl = createBonusCard(card);

            // N'ajouter l'événement de clic que si le bonus a encore des tours
            const bonusTours = parseInt(card.tourbonus) || 0;
            if (gameState.isMyTurn && bonusTours > 0) {
              cardEl.addEventListener("click", () => selectBonus(card.id));
              cardEl.classList.add("can-play");
            } else if (bonusTours <= 0) {
              cardEl.classList.add("depleted");
            }

            if (card.id === gameState.selectedBonus) {
              cardEl.classList.add("selected");
            }

            yourBonus.appendChild(cardEl);
          });

          // Afficher les cartes personnages de l'adversaire
          opponentCharacters.innerHTML = "";
          if (opponent && opponent.cards) {
            opponent.cards.personnages.forEach((card) => {
              const characterState = opponent.charactersState[card.id];
              const cardEl = createCharacterCard(card, characterState, true);

              // N'ajouter l'événement de clic que si le personnage est vivant
              if (
                gameState.isMyTurn &&
                gameState.selectedCharacter &&
                characterState &&
                characterState.currentHealth > 0
              ) {
                cardEl.addEventListener("click", () =>
                  selectOpponentCharacter(card.id)
                );
                cardEl.classList.add("can-target");
              }

              if (card.id === gameState.targetCharacter) {
                cardEl.classList.add("selected");
              }

              opponentCharacters.appendChild(cardEl);
            });
          }

          // Mettre à jour les boutons d'action
          updateActionButtons();

          // Si une attaque est en cours de traitement, ajouter une indication visuelle
          if (attackInProgress) {
            const message = document.createElement("div");
            message.className = "turn-info";
            message.textContent = "Changement de tour en cours...";
            message.style.position = "fixed";
            message.style.top = "50%";
            message.style.left = "50%";
            message.style.transform = "translate(-50%, -50%)";
            message.style.zIndex = "1000";
            message.style.padding = "20px";
            message.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
            message.style.color = "white";
            message.style.borderRadius = "8px";

            // Supprimer les anciennes notifications si elles existent
            const existingMessages = document.querySelectorAll(".turn-info");
            existingMessages.forEach((m) => m.remove());

            document.body.appendChild(message);

            // Supprimer après un court délai
            setTimeout(() => {
              message.remove();
            }, 2000);
          }
        }

        function createCharacterCard(card, state, isOpponent) {
          const cardEl = document.createElement("div");
          cardEl.className = `card ${
            isOpponent ? "opponent-card" : "personnage-card"
          }`;
          cardEl.dataset.id = card.id;

          // Récupérer les valeurs correctes
          const health =
            state && state.currentHealth !== undefined
              ? state.currentHealth
              : card.pointsdevie
              ? parseInt(card.pointsdevie)
              : 100;

          const attack =
            state && state.currentAttack !== undefined
              ? state.currentAttack
              : card.forceattaque
              ? parseInt(card.forceattaque)
              : 30;

          const turns =
            state && state.currentTurns !== undefined
              ? state.currentTurns
              : card.tourattaque
              ? parseInt(card.tourattaque)
              : 2;

          // Vérifier si des bonus sont actifs
          const activeBonus =
            state && state.activeBonus ? state.activeBonus : [];

          // Créer l'élément d'image
          let imageHtml = "";
          if (card.fond) {
            imageHtml = `<div class="card-image" style="background-image: url('${card.fond}')"></div>`;
          }

          // Indicateur de bonus actifs
          const bonusIndicator =
            activeBonus.length > 0
              ? `<div class="active-bonus-indicator">${activeBonus.length}</div>`
              : "";

          // Déterminer la classe de santé
          let healthClass = "normal";
          if (health <= 0) {
            healthClass = "depleted";
          } else if (health <= 30) {
            healthClass = "critical";
          } else if (health <= 50) {
            healthClass = "warning";
          }

          let healthDisplay = health;
          if (health <= 0) {
            healthDisplay = "KO";
          }

          // Construire le HTML de la carte simplifiée avec icônes
          cardEl.innerHTML = `
            ${imageHtml}
            ${bonusIndicator}
            <div style="position: absolute; top: 8px; left: 5px; right: 5px; z-index: 3; display: flex; flex-wrap: wrap; gap: 4px;">
              <div class="stat-item stat-hp"><span class="health-${healthClass}">${healthDisplay}</span></div>
              <div class="stat-item stat-attack">${attack}</div>
              <div class="stat-item stat-turns">${turns}</div>
            </div>
          `;

          return cardEl;
        }

        function createBonusCard(card) {
          const cardEl = document.createElement("div");
          cardEl.className = "card bonus-card";
          cardEl.dataset.id = card.id;

          // Ajouter la classe 'depleted' si le bonus n'a plus de tours
          if (parseInt(card.tourbonus) <= 0 || card.disabled) {
            cardEl.classList.add("depleted");
          }

          // Créer l'élément d'image
          let imageHtml = "";
          if (card.fond) {
            imageHtml = `<div class="card-image" style="background-image: url('${card.fond}')"></div>`;
          }

          // Récupérer les valeurs correctes
          const pourcentage = card.pourcentagebonus
            ? parseInt(card.pourcentagebonus)
            : 0;
          const tours = card.tourbonus ? parseInt(card.tourbonus) : 0;

          // Construire le HTML de la carte simplifiée avec icônes
          cardEl.innerHTML = `
            ${imageHtml}
            <div style="position: absolute; top: 8px; left: 5px; right: 5px; z-index: 3; display: flex; flex-wrap: wrap; gap: 4px;">
              <div class="stat-item stat-bonus">+${pourcentage}%</div>
              <div class="stat-item stat-turns">${tours}</div>
            </div>
          `;

          return cardEl;
        }

        function selectYourCharacter(cardId) {
          if (!gameState.isMyTurn) return;

          // Récupérer l'état du personnage
          const characterState =
            gameState.gameData.players[gameState.playerId].charactersState[
              cardId
            ];

          // Vérifier si le personnage est KO ou n'a plus de tours
          if (characterState && characterState.currentHealth <= 0) {
            showMessage(
              "Ce personnage est KO et ne peut pas être sélectionné",
              true
            );
            return;
          }

          if (characterState && characterState.currentTurns <= 0) {
            showMessage(
              "Ce personnage n'a plus de tours d'attaque disponibles",
              true
            );
            return;
          }

          // Si un bonus a été joué ce tour-ci
          if (gameState.bonusPlayedThisTurn) {
            // On ne peut sélectionner que le personnage qui a reçu le bonus
            if (cardId === gameState.lastBonusTarget) {
              gameState.selectedCharacter =
                gameState.selectedCharacter === cardId ? null : cardId;
            } else {
              showMessage(
                `Tour ${gameState.gameData.turnNumber}: Vous ne pouvez sélectionner que le personnage auquel vous avez appliqué un bonus ce tour-ci`,
                true
              );
              return;
            }
          } else {
            // Si aucun bonus n'a été joué ce tour-ci, on peut sélectionner n'importe quel personnage valide
            gameState.selectedCharacter =
              gameState.selectedCharacter === cardId ? null : cardId;
          }

          // Réinitialiser la cible si on change de personnage attaquant
          gameState.targetCharacter = null;

          updateActionButtons();
          renderCards();
        }

        function selectOpponentCharacter(cardId) {
          if (!gameState.isMyTurn || !gameState.selectedCharacter) return;

          if (gameState.targetCharacter === cardId) {
            gameState.targetCharacter = null;
          } else {
            gameState.targetCharacter = cardId;

            // Si on a sélectionné un personnage à attaquer, on peut proposer d'attaquer
            if (gameState.selectedCharacter && gameState.targetCharacter) {
              attackBtn.classList.remove("hidden");
            }
          }

          renderCards();
        }

        function selectBonus(cardId) {
          if (!gameState.isMyTurn) return;

          // Vérifier si le bonus est déjà sélectionné
          if (gameState.selectedBonus === cardId) {
            gameState.selectedBonus = null;
          } else {
            gameState.selectedBonus = cardId;
          }

          updateActionButtons();
          renderCards();
        }

        function updateActionButtons() {
          const actionButtons = document.getElementById("actionButtons");

          if (gameState.isMyTurn) {
            // Le bouton d'attaque est visible seulement si un personnage est sélectionné et une cible
            const canAttack =
              gameState.selectedCharacter && gameState.targetCharacter;
            attackBtn.style.display = canAttack ? "flex" : "none";

            // Le bouton pour jouer un bonus est visible seulement si un bonus et un personnage sont sélectionnés
            const canPlayBonus =
              gameState.selectedBonus && gameState.selectedCharacter;
            playBonusBtn.style.display = canPlayBonus ? "flex" : "none";

            // Si au moins un des boutons est visible, afficher le conteneur de boutons
            if (canAttack || canPlayBonus) {
              actionButtons.classList.remove("hidden");
            } else {
              actionButtons.classList.add("hidden");
            }
          } else {
            // Si ce n'est pas notre tour, cacher tous les boutons
            actionButtons.classList.add("hidden");
          }
        }

        // Modifier la fonction updateGameStatus pour afficher l'écran de fin quand la partie est terminée
        function updateGameStatus() {
          let statusText = "";

          if (gameState.gameData && gameState.gameData.status === "playing") {
            const turnNumber = gameState.gameData.turnNumber || 1;
            statusText = `<div class="turn-info">
              <span>${
                gameState.isMyTurn
                  ? "C'est votre tour!"
                  : "Au tour de l'adversaire"
              }</span>
              <span class="turn-number">Tour ${turnNumber}</span>
            </div>`;

            // Ajouter l'information sur l'attaque
            if (gameState.isMyTurn) {
              const attackStatus =
                gameState.gameData && gameState.gameData.attackPerformed
                  ? '<span class="attack-status">Attaque effectuée</span>'
                  : '<span class="attack-status">Attaque disponible</span>';

              statusText += attackStatus;
            }
          } else if (
            gameState.gameData &&
            gameState.gameData.status === "finished"
          ) {
            // Si la partie est terminée, afficher l'écran de fin de partie automatiquement
            if (gameState.gameData.winner === gameState.playerId) {
              statusText = "Victoire! La partie est terminée.";
              // Afficher l'écran de fin de partie avec un court délai pour que l'utilisateur voie le message
              setTimeout(() => {
                showGameOverScreen({
                  winner: gameState.playerId,
                  playersTotalHealth:
                    gameState.gameData.playersTotalHealth || null,
                  newGameState: gameState.gameData,
                });
              }, 1500);
            } else if (gameState.gameData.winner === "tie") {
              statusText = "Match nul! La partie est terminée.";
              // Afficher l'écran de fin de partie
              setTimeout(() => {
                showGameOverScreen({
                  winner: "tie",
                  playersTotalHealth:
                    gameState.gameData.playersTotalHealth || null,
                  newGameState: gameState.gameData,
                });
              }, 1500);
            } else {
              statusText = "Défaite! La partie est terminée.";
              // Afficher l'écran de fin de partie
              setTimeout(() => {
                showGameOverScreen({
                  winner: Object.keys(gameState.gameData.players).find(
                    (id) => id !== gameState.playerId
                  ),
                  playersTotalHealth:
                    gameState.gameData.playersTotalHealth || null,
                  newGameState: gameState.gameData,
                });
              }, 1500);
            }
          } else {
            statusText = "En attente d'un adversaire...";
          }

          gameStatus.innerHTML = statusText;
        }

        // Event handlers
        createGameBtn.addEventListener("click", () => {
          fetch("/api/games", {
            method: "POST",
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.success) {
                gameState.gameId = data.gameId;
                gameIdDisplay.textContent = data.gameId;
                showScreen("created");
              } else {
                showMessage("Erreur: " + data.error, true);
              }
            })
            .catch((error) => {
              showMessage("Erreur de connexion", true);
              console.error("Error:", error);
            });
        });

        joinGameBtn.addEventListener("click", () => {
          const name = document.getElementById("playerNameInput").value.trim();
          const gameId = document.getElementById("gameIdInput").value.trim();

          if (!name || !gameId) {
            showMessage("Nom et ID de partie requis", true);
            return;
          }

          joinGame(gameId, name);
        });

        joinAsCreatorBtn.addEventListener("click", () => {
          const name = document.getElementById("creatorNameInput").value.trim();

          if (!name) {
            showMessage("Nom requis", true);
            return;
          }

          joinGame(gameState.gameId, name);
        });

        copyGameIdBtn.addEventListener("click", () => {
          navigator.clipboard
            .writeText(gameState.gameId)
            .then(() => showMessage("ID copié!"))
            .catch(() => showMessage("Erreur de copie", true));
        });

        attackBtn.addEventListener("click", () => {
          if (
            !gameState.isMyTurn ||
            !gameState.selectedCharacter ||
            !gameState.targetCharacter
          )
            return;

          // La vérification d'attaque est maintenant inutile car le tour changera automatiquement
          // après une attaque, mais nous la gardons pour la sécurité (en cas de problème réseau)
          if (gameState.gameData.attackPerformed) {
            showMessage(
              "Vous avez déjà attaqué ce tour. C'est au tour de l'adversaire.",
              true
            );

            // NOUVEAU CODE : Ne pas permettre d'attaquer à nouveau
            return;
          }

          // Vérification que le personnage a des tours d'attaque et est en vie
          const game = gameState.gameData;
          const player = game.players[gameState.playerId];
          const attacker = player.charactersState[gameState.selectedCharacter];

          if (attacker.currentHealth <= 0) {
            showMessage(
              "Ce personnage est vaincu et ne peut pas attaquer.",
              true
            );
            return;
          }

          if (attacker.currentTurns <= 0) {
            showMessage(
              "Ce personnage n'a plus de tours d'attaque disponibles.",
              true
            );
            return;
          }

          // Trouver les noms des cartes pour l'affichage
          const attackerCard = player.cards.personnages.find(
            (c) => c.id === gameState.selectedCharacter
          );
          const attackerName = attackerCard
            ? attackerCard.nomcarteperso
            : gameState.selectedCharacter;

          // Trouver l'adversaire et la carte cible
          let opponent = null;
          for (const id in game.players) {
            if (id !== gameState.playerId) {
              opponent = game.players[id];
              break;
            }
          }

          let targetName = gameState.targetCharacter;
          if (opponent) {
            const targetCard = opponent.cards.personnages.find(
              (c) => c.id === gameState.targetCharacter
            );
            if (targetCard) {
              targetName = targetCard.nomcarteperso;
            }
          }

          socket.emit("attackCharacter", {
            gameId: gameState.gameId,
            playerId: gameState.playerId,
            attackerId: gameState.selectedCharacter,
            targetId: gameState.targetCharacter,
          });

          // Modification ici aussi: informer que le tour passe automatiquement
          showMessage(
            `${attackerName} attaque ${targetName}. Le tour passe à l'adversaire.`
          );

          // Mettre à jour l'affichage
          updateActionButtons();
          renderCards();
        });

        playBonusBtn.addEventListener("click", () => {
          if (
            !gameState.isMyTurn ||
            !gameState.selectedBonus ||
            !gameState.selectedCharacter
          )
            return;

          socket.emit("playBonus", {
            gameId: gameState.gameId,
            playerId: gameState.playerId,
            bonusId: gameState.selectedBonus,
            targetCharacterId: gameState.selectedCharacter,
          });

          // Marquer qu'un bonus a été joué ce tour-ci et sauvegarder la cible
          gameState.bonusPlayedThisTurn = true;
          gameState.lastBonusTarget = gameState.selectedCharacter;

          // Afficher un message explicite
          const bonusCard = gameState.gameData.players[
            gameState.playerId
          ].cards.bonus.find((b) => b.id === gameState.selectedBonus);
          const characterCard = gameState.gameData.players[
            gameState.playerId
          ].cards.personnages.find((c) => c.id === gameState.selectedCharacter);

          showMessage(
            `${bonusCard?.nomcartebonus || "Bonus"} joué sur ${
              characterCard?.nomcarteperso || gameState.selectedCharacter
            }`
          );
          showMessage(
            "Vous ne pourrez plus sélectionner d'autres personnages ce tour-ci"
          );

          // Réinitialiser seulement la sélection de bonus, garder le personnage sélectionné
          gameState.selectedBonus = null;
          renderCards();
        });

        // Game functions
        function joinGame(gameId, playerName) {
          showScreen("waiting");
          document.getElementById("waitingMessage").textContent =
            "Connexion en cours...";

          fetch(`/api/games/${gameId}/join`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name: playerName }),
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.success) {
                gameState.gameId = data.gameId;
                gameState.playerId = data.playerId;
                gameState.playerName = playerName;

                // Sauvegarder dans localStorage
                localStorage.setItem("gameId", data.gameId);
                localStorage.setItem("playerId", data.playerId);
                localStorage.setItem("playerName", playerName);

                // Connexion socket
                document.getElementById("waitingMessage").textContent =
                  "En attente d'un adversaire...";
                socket.emit("joinRoom", {
                  gameId: data.gameId,
                  playerId: data.playerId,
                });
              } else {
                showMessage("Erreur: " + data.error, true);
                showScreen("home");
              }
            })
            .catch((error) => {
              showMessage("Erreur de connexion", true);
              showScreen("home");
              console.error("Error:", error);
            });
        }

        // Socket.io Events
        socket.on("connect", () => {
          console.log("Connecté au serveur");
        });

        socket.on("error", (data) => {
          showMessage("Erreur: " + data.message, true);
        });

        socket.on("gameState", (data) => {
          console.log("État du jeu reçu:", data);

          gameState.gameData = data.game;
          gameState.isMyTurn =
            gameState.gameData.currentTurn === gameState.playerId;

          if (gameState.gameData.status === "playing") {
            showScreen("game");
            updateGameStatus();
            renderCards();
            debugCardProperties();
          }
        });

        socket.on("playerJoined", (data) => {
          showMessage(`${data.playerName} a rejoint la partie`);
        });

        socket.on("gameReady", (data) => {
          console.log("Partie prête:", data);
          gameState.gameData = data.game;
          gameState.isMyTurn = data.startingPlayer === gameState.playerId;

          // Initialiser le compteur de tour
          gameState.gameData.turnNumber = 1;
          console.log("Tour initial:", gameState.gameData.turnNumber);

          showScreen("game");
          updateGameStatus();
          renderCards();

          showMessage("La partie commence!");
        });

        socket.on("turnChanged", (data) => {
          console.log("Changement de tour:", data);
          gameState.isMyTurn = data.currentTurn === gameState.playerId;

          // Si c'est notre tour et que le tour précédent était celui de l'adversaire
          if (
            gameState.isMyTurn &&
            data.previousTurn &&
            data.previousTurn !== gameState.playerId
          ) {
            // Incrémenter le compteur de tour
            if (!gameState.gameData.turnNumber) {
              gameState.gameData.turnNumber = 1;
            } else {
              gameState.gameData.turnNumber++;
            }
            console.log("Nouveau tour:", gameState.gameData.turnNumber);
          }

          // IMPORTANT: Réinitialiser TOUS les flags au début de notre tour
          if (gameState.isMyTurn) {
            // Réinitialiser tous les flags
            gameState.bonusPlayedThisTurn = false;
            gameState.lastBonusTarget = null;
            gameState.selectedCharacter = null;
            gameState.selectedBonus = null;
            gameState.targetCharacter = null;

            // Mettre à jour l'état du jeu
            if (data.newGameState) {
              const oldTurnNumber = gameState.gameData.turnNumber;
              gameState.gameData = data.newGameState;
              // Préserver le numéro de tour
              gameState.gameData.turnNumber = oldTurnNumber;
              if (gameState.gameData) {
                gameState.gameData.attackPerformed = false;
              }
            }

            showMessage(
              `Tour ${gameState.gameData.turnNumber}: C'est votre tour! Vous pouvez sélectionner n'importe quel personnage.`
            );
          } else {
            showMessage(
              `Tour ${gameState.gameData.turnNumber}: Au tour de l'adversaire`
            );
          }

          showTurnChange(gameState.isMyTurn);
          updateGameStatus();
          updateActionButtons();
          renderCards();
        });

        socket.on("bonusPlayed", (data) => {
          if (!gameState.gameData) return;

          // Si le serveur nous a envoyé un nouvel état du jeu, l'utiliser
          if (data.newGameState) {
            gameState.gameData = data.newGameState;
          } else {
            // Sinon, simuler l'application du bonus côté client
            const { playerId, bonusId, targetCharacterId } = data;

            // Récupérer le jeu et le joueur
            const game = gameState.gameData;
            const player = game.players[playerId];

            if (
              player &&
              player.charactersState &&
              player.charactersState[targetCharacterId]
            ) {
              // Trouver la carte de bonus correspondante
              const bonusCard = player.cards.bonus.find(
                (card) => card.id === bonusId
              );
              if (bonusCard) {
                // Appliquer l'effet du bonus (augmentation de l'attaque)
                const characterState =
                  player.charactersState[targetCharacterId];
                const baseAttack =
                  characterState.baseAttack || characterState.currentAttack;
                const bonusPercentage = bonusCard.pourcentagebonus
                  ? parseInt(bonusCard.pourcentagebonus)
                  : 0;

                // Appliquer le bonus: force * (1 + bonus/100)
                characterState.currentAttack = Math.floor(
                  baseAttack * (1 + bonusPercentage / 100)
                );

                // Sauvegarder la valeur d'attaque originale si ce n'est pas déjà fait
                if (!characterState.baseAttack) {
                  characterState.baseAttack = baseAttack;
                }

                // Ajouter le bonus à la liste des bonus actifs
                if (!characterState.activeBonus) {
                  characterState.activeBonus = [];
                }

                // Ajouter les détails du bonus
                characterState.activeBonus.push({
                  bonusId: bonusId,
                  remainingTurns: bonusCard.tourbonus
                    ? parseInt(bonusCard.tourbonus)
                    : 1,
                  percentage: bonusPercentage,
                  name: bonusCard.nomcartebonus || bonusId,
                });
              }
            }
          }

          // Afficher un message avec le nom de la carte si disponible
          const bonusName =
            data.bonusName ||
            gameState.gameData.players[data.playerId]?.cards.bonus.find(
              (c) => c.id === data.bonusId
            )?.nomcartebonus ||
            "Un bonus";

          const targetName =
            data.targetName ||
            gameState.gameData.players[data.playerId]?.cards.personnages.find(
              (c) => c.id === data.targetCharacterId
            )?.nomcarteperso ||
            "un personnage";

          showMessage(`${bonusName} a été joué sur ${targetName}`);

          // Mettre à jour l'affichage
          renderCards();
        });

        socket.on("characterAttacked", (data) => {
          // Mettre à jour l'état du jeu avec les nouvelles valeurs
          if (gameState.gameData && data.newGameState) {
            gameState.gameData = data.newGameState;

            // Si le serveur indique que le tour a changé
            if (data.turnChanged) {
              // Réinitialiser TOUTES les sélections lors du changement de tour
              gameState.selectedCharacter = null;
              gameState.targetCharacter = null;
              gameState.selectedBonus = null;

              gameState.isMyTurn = data.newCurrentTurn === gameState.playerId;

              // Message approprié pour le changement de tour
              if (gameState.isMyTurn) {
                showMessage(
                  "L'adversaire a attaqué. C'est maintenant votre tour!"
                );
              } else {
                showMessage("Vous avez attaqué. Au tour de l'adversaire!");
              }
            }

            // Mettre à jour l'interface
            updateGameStatus();
            updateActionButtons();
            renderCards();

            // Vérifier si la partie est terminée
            checkGameOver();
          }

          // Afficher le message d'attaque
          showMessage(
            `${data.attackerName || "Un personnage"} a attaqué ${
              data.targetName || "un autre personnage"
            } pour ${data.damage || "des"} dégâts!`
          );
        });

        socket.on("playerLeft", (data) => {
          showMessage("L'adversaire s'est déconnecté");
        });

        socket.on("gameOver", (data) => {
          console.log("Réception de l'événement gameOver", data);

          // Mettre à jour l'état du jeu
          if (data.newGameState) {
            gameState.gameData = data.newGameState;
          }

          // Marquer la partie comme terminée
          if (gameState.gameData) {
            gameState.gameData.status = "finished";
            gameState.gameData.winner = data.winner;
            if (data.playersTotalHealth) {
              gameState.gameData.playersTotalHealth = data.playersTotalHealth;
            }
          }

          // Afficher l'écran de fin de partie après un court délai
          setTimeout(() => {
            showGameOverScreen(data);
          }, 500);
        });

        // Check for existing game in localStorage
        const savedGameId = localStorage.getItem("gameId");
        const savedPlayerId = localStorage.getItem("playerId");
        const savedPlayerName = localStorage.getItem("playerName");

        if (savedGameId && savedPlayerId) {
          const rejoin = confirm(
            "Partie en cours trouvée. Voulez-vous la rejoindre?"
          );
          if (rejoin) {
            gameState.gameId = savedGameId;
            gameState.playerId = savedPlayerId;
            gameState.playerName = savedPlayerName;

            showScreen("waiting");
            document.getElementById("waitingMessage").textContent =
              "Reconnexion en cours...";
            socket.emit("joinRoom", {
              gameId: savedGameId,
              playerId: savedPlayerId,
            });
          } else {
            localStorage.removeItem("gameId");
            localStorage.removeItem("playerId");
            localStorage.removeItem("playerName");
          }
        }

        // Ajouter une fonction pour vérifier si la partie est gagnée/perdue
        function checkGameOver() {
          if (!gameState.gameData) return false;

          const game = gameState.gameData;
          const player = game.players[gameState.playerId];

          // Trouver l'adversaire
          let opponent = null;
          for (const id in game.players) {
            if (id !== gameState.playerId) {
              opponent = game.players[id];
              break;
            }
          }

          if (!player || !opponent) return false;

          let gameEnded = false;
          let winner = null;
          let reason = "";
          let playersTotalHealth = {};

          // Calculer les points de vie totaux
          const playerTotalHealth = Object.values(
            player.charactersState
          ).reduce((total, char) => total + Math.max(0, char.currentHealth), 0);

          const opponentTotalHealth = Object.values(
            opponent.charactersState
          ).reduce((total, char) => total + Math.max(0, char.currentHealth), 0);

          playersTotalHealth[gameState.playerId] = playerTotalHealth;
          playersTotalHealth[opponent.id] = opponentTotalHealth;

          // RÈGLE 1: Vérifier si tous les personnages d'un joueur sont à 0 PV
          const playerHasAliveChars = Object.values(
            player.charactersState
          ).some((char) => char.currentHealth > 0);
          const opponentHasAliveChars = Object.values(
            opponent.charactersState
          ).some((char) => char.currentHealth > 0);

          // Si un joueur n'a plus de personnages en vie, il a perdu
          if (!playerHasAliveChars) {
            winner = opponent.id;
            reason = "Tous vos personnages sont vaincus";
            gameEnded = true;
          } else if (!opponentHasAliveChars) {
            winner = gameState.playerId;
            reason = "Tous les personnages adverses sont vaincus";
            gameEnded = true;
          } else {
            // RÈGLE 2 & 3: Vérifier si les joueurs peuvent encore attaquer
            const playerCanAttack = Object.values(player.charactersState).some(
              (char) => char.currentHealth > 0 && char.currentTurns > 0
            );

            const opponentCanAttack = Object.values(
              opponent.charactersState
            ).some((char) => char.currentHealth > 0 && char.currentTurns > 0);

            // Si aucun des deux joueurs ne peut attaquer, la partie se termine
            if (!playerCanAttack && !opponentCanAttack) {
              if (playerTotalHealth > opponentTotalHealth) {
                winner = gameState.playerId;
              } else if (opponentTotalHealth > playerTotalHealth) {
                winner = opponent.id;
              } else {
                winner = "tie";
              }
              reason = "Plus aucun joueur ne peut attaquer";
              gameEnded = true;
            }
          }

          if (gameEnded) {
            // Afficher un message selon le résultat
            if (winner === gameState.playerId) {
              showMessage("Partie terminée ! Vous gagnez " + reason);
            } else if (winner === "tie") {
              showMessage("Partie terminée ! Match nul " + reason);
            } else {
              showMessage("Partie terminée ! Vous perdez " + reason, true);
            }

            // Informer le serveur de la fin de partie
            socket.emit("gameEnded", {
              gameId: gameState.gameId,
              winner: winner,
              playersTotalHealth: playersTotalHealth,
            });

            // Afficher directement l'écran de fin de partie
            setTimeout(() => {
              showGameOverScreen({
                winner: winner,
                playersTotalHealth: playersTotalHealth,
                newGameState: game,
              });
            }, 1000);

            return true;
          }

          return false;
        }

        // Fonction pour ajouter la possibilité de zoomer sur les cartes
        function setupCardZoom() {
          // Fonction pour zoomer une carte
          function zoomCard(card) {
            // Créer un overlay de fond
            const overlay = document.createElement("div");
            overlay.className = "overlay-background";
            document.body.appendChild(overlay);

            // Cloner la carte pour l'afficher en grand
            const zoomedCard = card.cloneNode(true);
            zoomedCard.classList.add("card-zoom");
            document.body.appendChild(zoomedCard);

            // Cliquer n'importe où pour fermer
            function closeZoom() {
              document.body.removeChild(overlay);
              document.body.removeChild(zoomedCard);
              document.removeEventListener("click", closeZoom);
            }

            document.addEventListener("click", closeZoom);
          }

          // Écouter les clics longs sur les cartes
          document.addEventListener("mousedown", function (e) {
            // Vérifier si c'est une carte
            let card = null;
            if (e.target.classList.contains("card")) {
              card = e.target;
            } else if (e.target.closest(".card")) {
              card = e.target.closest(".card");
            }

            if (card) {
              const timer = setTimeout(() => {
                zoomCard(card);
              }, 500); // Zoom après 500ms

              // Annuler le zoom si le clic est relâché avant
              const clearTimer = () => {
                clearTimeout(timer);
                document.removeEventListener("mouseup", clearTimer);
              };

              document.addEventListener("mouseup", clearTimer);
            }
          });
        }

        // Appeler cette fonction après le chargement du DOM
        setupCardZoom();

        // Ajouter cette fonction pour déboguer le contenu des cartes
        function debugCardProperties() {
          if (!gameState.gameData) return;

          const game = gameState.gameData;
          const player = game.players[gameState.playerId];

          if (player && player.cards) {
            console.log("Propriétés des cartes personnages:");
            if (
              player.cards.personnages &&
              player.cards.personnages.length > 0
            ) {
              console.table(player.cards.personnages[0]);
            }

            console.log("Propriétés des cartes bonus:");
            if (player.cards.bonus && player.cards.bonus.length > 0) {
              console.table(player.cards.bonus[0]);
            }
          }
        }

        // Ajouter cette fonction pour mieux visualiser les changements de tour
        function showTurnChange(isMyTurn) {
          // Créer un élément de notification de changement de tour
          const notification = document.createElement("div");
          notification.className = "turn-change-notification";
          notification.textContent = isMyTurn
            ? "À VOTRE TOUR"
            : "AU TOUR DE L'ADVERSAIRE";
          notification.style.position = "fixed";
          notification.style.top = "40%";
          notification.style.left = "50%";
          notification.style.transform = "translate(-50%, -50%)";
          notification.style.zIndex = "1000";
          notification.style.padding = "30px 50px";
          notification.style.backgroundColor = isMyTurn
            ? "rgba(76, 175, 80, 0.9)"
            : "rgba(255, 152, 0, 0.9)";
          notification.style.color = "white";
          notification.style.borderRadius = "8px";
          notification.style.fontWeight = "bold";
          notification.style.fontSize = "24px";
          notification.style.boxShadow = "0 4px 20px rgba(0, 0, 0, 0.4)";
          notification.style.transition = "opacity 0.5s";

          document.body.appendChild(notification);

          // Faire disparaître progressivement la notification
          setTimeout(() => {
            notification.style.opacity = "0";
          }, 1500);

          // Supprimer l'élément après l'animation
          setTimeout(() => {
            document.body.removeChild(notification);
          }, 2000);
        }

        // Ajoutez les gestionnaires d'événements pour les boutons de fin de partie
        newGameBtn.addEventListener("click", startNewGame);
        quitGameBtn.addEventListener("click", returnToMenu);

        // Fonction pour démarrer une nouvelle partie
        function startNewGame() {
          // Réinitialiser les sélections et l'état du jeu
          gameState.selectedCharacter = null;
          gameState.selectedBonus = null;
          gameState.targetCharacter = null;

          // Créer une nouvelle partie
          fetch("/api/games", {
            method: "POST",
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.success) {
                gameState.gameId = data.gameId;
                gameIdDisplay.textContent = data.gameId;

                // Sauvegarder le nouvel ID de partie
                localStorage.setItem("gameId", data.gameId);

                // Rejoindre automatiquement la nouvelle partie
                joinGame(data.gameId, gameState.playerName);

                // Cacher l'écran de fin de partie
                gameOverScreen.classList.add("hidden");
              } else {
                showMessage(
                  "Erreur lors de la création d'une nouvelle partie: " +
                    data.error,
                  true
                );
              }
            })
            .catch((error) => {
              showMessage("Erreur de connexion", true);
              console.error("Error:", error);
            });
        }

        // Fonction pour retourner au menu principal
        function returnToMenu() {
          console.log("Retour au menu principal");

          // Effacer les données de la partie
          localStorage.removeItem("gameId");
          localStorage.removeItem("playerId");
          localStorage.removeItem("playerName");

          // Réinitialiser l'état du jeu
          gameState = {
            gameId: null,
            playerId: null,
            playerName: null,
            isMyTurn: false,
            gameData: null,
            selectedCharacter: null,
            selectedBonus: null,
            targetCharacter: null,
            bonusPlayedThisTurn: false,
            lastBonusTarget: null,
          };

          // Cacher tous les écrans
          gameOverScreen.classList.add("hidden");
          screens.game.classList.add("hidden");
          screens.waiting.classList.add("hidden");
          screens.created.classList.add("hidden");

          // Vider les conteneurs de cartes
          yourCharacters.innerHTML = "";
          yourBonus.innerHTML = "";
          opponentCharacters.innerHTML = "";

          // Réinitialiser les champs d'entrée
          document.getElementById("playerNameInput").value = "";
          document.getElementById("gameIdInput").value = "";
          document.getElementById("creatorNameInput").value = "";

          // Réinitialiser les messages
          messages.innerHTML = "";

          // Afficher l'écran d'accueil
          screens.home.classList.remove("hidden");

          // Réinitialiser le socket
          socket.emit("disconnect");

          // Forcer le rafraîchissement de la page si nécessaire
          if (!screens.home.classList.contains("hidden")) {
            console.log("Page d'accueil affichée avec succès");
          } else {
            console.log(
              "Échec de l'affichage de la page d'accueil, tentative de rafraîchissement"
            );
            window.location.href = window.location.href;
          }
        }

        // Fonction pour afficher l'écran de fin de partie
        function showGameOverScreen(data) {
          console.log("Affichage de l'écran de fin de partie", data);

          // Arrêter toutes les activités de la partie en cours
          socket.emit("leaveRoom", {
            gameId: gameState.gameId,
            playerId: gameState.playerId,
          });

          // Cacher tous les écrans
          Object.keys(screens).forEach((key) => {
            screens[key].classList.add("hidden");
          });

          // Réinitialiser les sélections
          gameState.selectedCharacter = null;
          gameState.selectedBonus = null;
          gameState.targetCharacter = null;

          // Configurer le message selon le résultat
          if (data.winner === gameState.playerId) {
            gameOverTitle.textContent = "🏆 Victoire !";
            gameOverMessage.textContent =
              "Félicitations, vous avez gagné la partie !";
            gameOverMessage.className = "message-victory";
          } else if (data.winner === "tie") {
            gameOverTitle.textContent = "🤝 Match nul !";
            gameOverMessage.textContent =
              "La partie s'est terminée par une égalité.";
            gameOverMessage.className = "message-tie";
          } else {
            gameOverTitle.textContent = "💔 Défaite !";
            gameOverMessage.textContent =
              "Vous avez perdu la partie. Réessayez !";
            gameOverMessage.className = "message-defeat";
          }

          // Afficher les statistiques des joueurs
          playerStats.innerHTML = "";

          // Si nous avons les données des PV restants
          if (data.playersTotalHealth) {
            const playerIds = Object.keys(data.playersTotalHealth);
            playerIds.forEach((pid) => {
              let playerName = "Joueur inconnu";
              if (
                gameState.gameData &&
                gameState.gameData.players &&
                gameState.gameData.players[pid]
              ) {
                playerName = gameState.gameData.players[pid].name;
              }
              const totalHealth = data.playersTotalHealth[pid];
              const isWinner = pid === data.winner;

              const statDiv = document.createElement("div");
              statDiv.className = `player-stat ${isWinner ? "winner" : ""}`;
              statDiv.innerHTML = `
                <span>${playerName} ${isWinner ? "🏆" : ""}</span>
                <span>${totalHealth} PV restants</span>
              `;

              playerStats.appendChild(statDiv);
            });
          } else if (gameState.gameData && gameState.gameData.players) {
            // Si nous n'avons pas les données détaillées
            for (const pid in gameState.gameData.players) {
              const playerName = gameState.gameData.players[pid].name;
              const isWinner = pid === data.winner;

              const statDiv = document.createElement("div");
              statDiv.className = `player-stat ${isWinner ? "winner" : ""}`;
              statDiv.innerHTML = `
                <span>${playerName} ${isWinner ? "🏆" : ""}</span>
                <span>${
                  isWinner ? "Tous les personnages adverses sont K.O." : ""
                }</span>
              `;

              playerStats.appendChild(statDiv);
            }
          }

          // S'assurer que l'écran de fin est visible
          gameOverScreen.classList.remove("hidden");

          // Définir explicitement les fonctions des boutons et s'assurer qu'ils sont visibles
          newGameBtn.style.display = "block";
          quitGameBtn.style.display = "block";

          // Supprimer tous les gestionnaires d'événements existants
          newGameBtn.replaceWith(newGameBtn.cloneNode(true));
          quitGameBtn.replaceWith(quitGameBtn.cloneNode(true));

          // Récupérer les références des nouveaux boutons
          const newNewGameBtn = document.getElementById("newGameBtn");
          const newQuitGameBtn = document.getElementById("quitGameBtn");

          // Ajouter les nouveaux gestionnaires d'événements
          newNewGameBtn.addEventListener("click", function () {
            gameOverScreen.classList.add("hidden");
            startNewGame();
          });

          newQuitGameBtn.addEventListener("click", function () {
            gameOverScreen.classList.add("hidden");
            returnToMenu();
          });

          console.log("Écran de fin de partie affiché avec boutons");
        }
      });
    </script>
  </body>
</html>
