<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Victorryan</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        margin-top: 20px;
      }
      .hidden {
        display: none;
      }
      button {
        padding: 8px 16px;
        background-color: #4caf50;
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 4px;
        margin: 5px;
      }
      button:hover {
        background-color: #45a049;
      }
      input {
        padding: 8px;
        margin-bottom: 10px;
        width: 100%;
        border-radius: 4px;
        border: 1px solid #ddd;
      }
      .game-id {
        background-color: #f1f1f1;
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      /* Styles pour les cartes */
      .cards-container {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 15px;
        justify-content: center;
      }

      .card {
        width: auto;
        min-width: 180px;
        max-width: 190px;
        height: auto;
        min-height: 280px;
        max-height: 300px;
        border-radius: 10px;
        padding: 0;
        margin: 0 8px 15px 8px;
        background-color: transparent;
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
        cursor: pointer;
        position: relative;
        overflow: visible;
        display: inline-block;
      }

      .card:hover {
        transform: translateY(-8px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
      }

      .card-image {
        width: 100%;
        height: 100%;
        background-size: 100% 100%;
        background-position: center;
        background-repeat: no-repeat;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1;
        border-radius: 10px;
      }

      .card-title {
        display: none;
      }

      .card-stats {
        position: absolute;
        top: 5px;
        left: 5px;
        right: 5px;
        z-index: 3;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        background: none;
        margin: 0;
        padding: 0;
      }

      .card-overlay {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: transparent;
        padding: 0;
        border-top: none;
        backdrop-filter: none;
        z-index: 2;
      }

      .personnage-card {
        background-color: #e8f5e9;
      }

      .bonus-card {
        background-color: #e3f2fd;
      }

      .opponent-card {
        background-color: #fff3e0;
      }

      .player-section {
        background-color: white;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .game-status {
        background-color: #333;
        color: white;
        padding: 10px;
        text-align: center;
        border-radius: 4px;
        margin-bottom: 20px;
      }

      .actions {
        display: flex;
        justify-content: center;
        margin-top: 20px;
      }

      .active-bonus-indicator {
        position: absolute;
        top: 5px;
        right: 5px;
        background-color: rgba(255, 152, 0, 0.8);
        color: white;
        border-radius: 50%;
        width: 26px;
        height: 26px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
        z-index: 5;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .game-info {
        background-color: #f1f1f1;
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
      }

      .turn-indicator {
        font-weight: bold;
        color: #4caf50;
      }

      /* Ajouter une classe pour agrandir la carte au survol */
      .card-zoom {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(2) !important;
        z-index: 1000;
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.5) !important;
      }

      /* Ajoutez un fond semi-transparent quand une carte est zoomée */
      .overlay-background {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 999;
      }

      .card.depleted {
        opacity: 0.6;
        filter: grayscale(70%);
      }

      .card.cannot-attack {
        opacity: 0.7;
        background-color: #ffebee;
        border: 2px solid #ffcdd2;
        position: relative;
      }

      .card.cannot-attack::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
          45deg,
          rgba(244, 67, 54, 0.1),
          rgba(244, 67, 54, 0.1) 10px,
          rgba(244, 67, 54, 0.2) 10px,
          rgba(244, 67, 54, 0.2) 20px
        );
        border-radius: 12px;
        pointer-events: none;
        z-index: 2;
      }

      .card.can-attack {
        border: 3px solid #4caf50;
        box-shadow: 0 0 12px rgba(76, 175, 80, 0.8);
      }

      .card.can-target {
        border: 3px solid #f44336;
        box-shadow: 0 0 12px rgba(244, 67, 54, 0.8);
      }

      .turn-info {
        background-color: #333;
        color: white;
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .turn-number {
        font-weight: bold;
        color: #4caf50;
        background-color: rgba(255, 255, 255, 0.1);
        padding: 5px 10px;
        border-radius: 4px;
        margin-left: 10px;
      }

      .attack-status {
        background-color: #ff9800;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        display: inline-block;
        margin-left: 10px;
      }

      .turn-change-notification {
        position: fixed;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        padding: 30px 50px;
        background-color: rgba(76, 175, 80, 0.9);
        color: white;
        border-radius: 8px;
        font-weight: bold;
        font-size: 24px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        transition: opacity 0.5s;
      }

      /* Amélioration des états visuels des cartes */
      .card.selected {
        transform: translateY(-12px);
        border: 3px solid #ffd700;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.7),
          inset 0 0 10px rgba(255, 215, 0, 0.3);
        animation: selectedPulse 2s infinite;
      }

      @keyframes selectedPulse {
        0% {
          box-shadow: 0 0 20px rgba(255, 215, 0, 0.7),
            inset 0 0 10px rgba(255, 215, 0, 0.3);
        }
        50% {
          box-shadow: 0 0 30px rgba(255, 215, 0, 0.9),
            inset 0 0 15px rgba(255, 215, 0, 0.5);
        }
        100% {
          box-shadow: 0 0 20px rgba(255, 215, 0, 0.7),
            inset 0 0 10px rgba(255, 215, 0, 0.3);
        }
      }

      .card.selected .card-image {
        filter: brightness(120%) contrast(110%);
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
        }
        50% {
          box-shadow: 0 0 25px rgba(76, 175, 80, 0.9);
        }
        100% {
          box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
        }
      }

      /* Styles pour l'écran de fin de partie */
      .game-over-container {
        background-color: rgba(255, 255, 255, 0.95);
        border-radius: 15px;
        padding: 40px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        max-width: 700px;
        margin: 0 auto;
        text-align: center;
        backdrop-filter: blur(5px);
        animation: fadeIn 0.6s ease-out, floatUp 0.8s ease-out;
      }

      @keyframes floatUp {
        from {
          transform: translateY(30px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      #gameOverTitle {
        font-size: 42px;
        margin-bottom: 20px;
        color: #333;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      }

      #gameOverMessage {
        font-size: 20px;
        margin-bottom: 30px;
        padding: 20px;
        border-radius: 10px;
      }

      .message-victory {
        background-color: #e8f5e9;
        border-left: 5px solid #4caf50;
        color: #2e7d32;
      }

      .message-defeat {
        background-color: #ffebee;
        border-left: 5px solid #f44336;
        color: #c62828;
      }

      .message-tie {
        background-color: #e3f2fd;
        border-left: 5px solid #2196f3;
        color: #1565c0;
      }

      .stats-container {
        background-color: rgba(245, 245, 245, 0.9);
        border-radius: 12px;
        padding: 25px;
        margin-bottom: 40px;
      }

      .player-stat {
        display: flex;
        justify-content: space-between;
        margin-bottom: 15px;
        padding: 15px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
      }

      .player-stat:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      }

      .player-stat.winner {
        background-color: rgba(232, 245, 233, 0.9);
        font-weight: bold;
        border-left: 5px solid #4caf50;
      }

      .game-over-actions {
        display: flex;
        justify-content: center;
        gap: 30px;
        margin-top: 30px;
      }

      .btn {
        padding: 15px 30px;
        font-size: 18px;
        border-radius: 30px;
        cursor: pointer;
        transition: all 0.3s;
        border: none;
        font-weight: bold;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 7px 14px rgba(0, 0, 0, 0.15);
      }

      .btn:active {
        transform: translateY(1px);
      }

      #newGameBtn {
        background-color: #4caf50;
        color: white;
      }

      #newGameBtn:hover {
        background-color: #3d8b40;
      }

      .btn-secondary {
        background-color: #f5f5f5;
        color: #333;
      }

      .btn-secondary:hover {
        background-color: #e0e0e0;
      }

      /* S'assurer que l'écran de fin est bien visible */
      #gameOverScreen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        padding: 20px;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        min-width: 300px;
      }

      #gameOverScreen.hidden {
        display: none;
      }

      /* Style simplifié pour les statistiques */
      .stat-item {
        display: inline-flex;
        align-items: center;
        margin: 3px;
        padding: 3px 8px;
        border-radius: 10px;
        font-weight: bold;
        font-size: 14px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      }

      .stat-hp {
        border-left: none;
        color: white;
      }

      .stat-hp::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        margin-right: 4px;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="red" d="M47.6 300.4L228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6 0 115.2 0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"/></svg>');
        background-repeat: no-repeat;
        background-position: center;
        background-size: contain;
      }

      .stat-attack {
        border-left: none;
        color: white;
      }

      .stat-attack::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        margin-right: 4px;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="lightblue" d="M320 146c12.9 0 24.8 3.9 34.8 10.4 10.8 7.1 19.4 17.2 24.8 29.5 6.5 15 5.8 28.1 3.8 36.9-2.3 10.2-7.5 17.5-11.8 22.8-5.2 6.4-11.6 12-18.7 16.6-2.8 1.8-5.7 3.5-8.7 5-4.5 2.3-9.2 4.2-14 5.7L313 401.2c-1.7 10.1-10.4 17.5-20.8 17.5-5.4 0-10.4-2-14.2-5.4-3.5-3.2-5.9-7.5-6.5-12.3l-10.4-84.9-5.2 .7c-10 1.3-19.6-5.9-21.6-15.7l-7.1-35.5c-1.9-9.6 4.1-18.9 13.5-21.5l46.2-12.6-22-6.1c-9.1-2.5-15.1-10.9-14.5-19.9 .6-9.2 7.5-16.7 16.3-19h.3l14.6-3.5L299.8 172c-10.1-2-16.7-11.6-15-21.4 1.3-8 7.3-14.3 14.9-16.2 .7-.2 1.5-.3 2.3-.4h13.7 4.3zm-83.8 198L233 381.7c-3 35.4-32.9 62.3-68.5 62.3-22.1 0-41.8-10.5-54.3-26.7L32.7 323.9C11.4 296.3 .3 262.4 3.1 228.2S22.6 164.8 49.2 142c13.3-11.4 31.4-14.9 47.8-9.1 14.2 5 25.2 16.2 30 30.4l9 27.1c3.3 9.8 13.9 15.2 23.7 11.9s15.1-13.9 11.9-23.7l-9-27.1c-8.6-25.8-27.6-45.5-51.8-54.9-25.3-9.8-53.1-6.7-75.9 8.4l-1.1 .7c-36.3 31-59.2 75.7-63.7 124.8s10.3 97.8 40.2 138.1l77.5 93.5c21.4 25.8 53.2 40.8 87.2 40.8 59.5 0 108.2-45.3 113.9-103.7l5.8-59.1-18.8-1.1c-10.5-.6-18.5-9.5-18-20zm276-25.6L444.1 351c-18.3 14.2-40.2 21.4-62.2 21.1-21.6-.3-40.6-7.8-53.3-21.6l-5.7-6.2c-7.1-7.7-6.6-19.8 1.2-26.9s19.8-6.6 26.9 1.2l5.7 6.2c6.9 7.5 16.9 11.2 29.2 11.4 12.5 .2 25.4-3.6 35.7-11.6l68.6-53.1-11.7-15-69.8 54.1c-.2 .2-.4 .3-.5 .5-2.5 2.5-5.9 3.8-9.3 3.7-3.1-.1-6.2-1.5-8.4-3.8l-58.7-63.7c-5.5-5.9-11.8-8.5-16.1-9.5l7.4 35.2 118.9-15.9c5.9-.8 11.8 1.1 16.4 5.1s7.1 9.9 7.1 16v13.4c0 8.4-5.5 15.9-13.6 18.4zM445.8 266.7c-11.5 1.5-21.4-6.5-22.9-18s6.5-21.4 18-22.9l58.1-7.8c6.1-.8 11.3 1.3 14.9 5.3s5.2 9.5 4.3 14.4c-1.5 8.4-7.8 14.5-16.1 15.6l-56.3 13.4z"/></svg>');
        background-repeat: no-repeat;
        background-position: center;
        background-size: contain;
      }

      .stat-turns {
        border-left: none;
        color: white;
      }

      .stat-turns::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        margin-right: 4px;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="lightgreen" d="M464 256A208 208 0 1 1 48 256a208 208 0 1 1 416 0zM0 256a256 256 0 1 0 512 0A256 256 0 1 0 0 256zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/></svg>');
        background-repeat: no-repeat;
        background-position: center;
        background-size: contain;
      }

      .stat-bonus {
        border-left: none;
        color: white;
      }

      .stat-bonus::before {
        content: "";
        display: inline-block;
        width: 12px;
        height: 12px;
        margin-right: 4px;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="orange" d="M400 0H176c-26.5 0-48.1 21.8-47.1 48.2c.2 5.3 .4 10.6 .7 15.8H24C10.7 64 0 74.7 0 88c0 92.6 33.5 157 78.5 200.7c44.3 43.1 98.3 64.8 138.1 75.8c23.4 6.5 39.4 26 39.4 45.6c0 20.9-17 37.9-37.9 37.9H192c-17.7 0-32 14.3-32 32s14.3 32 32 32H384c17.7 0 32-14.3 32-32s-14.3-32-32-32H357.9C337 448 320 431 320 410.1c0-19.6 15.9-39.2 39.4-45.6c39.9-11 93.9-32.7 138.2-75.8C542.5 245 576 180.6 576 88c0-13.3-10.7-24-24-24H446.4c.3-5.2 .5-10.4 .7-15.8C448.1 21.8 426.5 0 400 0zM48.9 112h84.4c9.1 90.1 29.2 150.3 51.9 190.6c-24.9-11-50.8-26.5-73.2-48.3c-32-31.1-58-76-63-142.3zM464.1 254.3c-22.4 21.8-48.3 37.3-73.2 48.3c22.7-40.3 42.8-100.5 51.9-190.6h84.4c-5.1 66.3-31.1 111.2-63 142.3z"/></svg>');
        background-repeat: no-repeat;
        background-position: center;
        background-size: contain;
      }

      /* Style pour les statuts de santé */
      .health-depleted {
        color: #ff5252;
        font-weight: bold;
        text-decoration: line-through;
      }

      .health-critical {
        color: #ff5252;
        font-weight: bold;
      }

      .health-warning {
        color: #ffb74d;
      }

      .health-normal {
        color: #81c784;
      }

      /* Style pour les cartes épuisées */
      .card.depleted .card-image {
        filter: grayscale(70%) brightness(70%);
      }

      /* Boutons d'action flottants */
      .action-buttons {
        position: fixed;
        bottom: 30px;
        left: 0;
        right: 0;
        display: flex;
        justify-content: center;
        gap: 15px;
        z-index: 1000;
        padding: 15px;
        background-color: rgba(51, 51, 51, 0.8);
        border-radius: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        margin: 0 auto;
        max-width: 600px;
        backdrop-filter: blur(5px);
        transition: transform 0.3s, opacity 0.3s;
      }

      .action-buttons.hidden {
        transform: translateY(100px);
        opacity: 0;
        pointer-events: none;
      }

      .action-button {
        padding: 12px 20px;
        border-radius: 30px;
        border: none;
        font-weight: bold;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        min-width: 120px;
      }

      .action-button:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
      }

      .action-button:active {
        transform: translateY(1px);
      }

      .attack-button {
        background-color: #f44336;
        color: white;
      }

      .bonus-button {
        background-color: #ff9800;
        color: white;
      }

      .game-over-screen {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        text-align: center;
        background: rgba(0, 0, 0, 0.9);
        border-radius: 1rem;
        max-width: 800px;
        margin: 2rem auto;
      }

      .game-over-screen h2 {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        color: #ffd700;
      }

      .game-over-screen p {
        font-size: 1.2rem;
        margin-bottom: 2rem;
        color: #fff;
      }

      .player-stats {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 0.5rem;
        padding: 1rem;
        margin: 1rem 0;
        width: 100%;
      }

      .player-stats h3 {
        color: #ffd700;
        margin-bottom: 1rem;
        font-size: 1.5rem;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
      }

      .character-stat {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 0.5rem;
        padding: 0.5rem;
        text-align: left;
      }

      .character-name {
        color: #fff;
        font-weight: bold;
        margin-bottom: 0.5rem;
      }

      .stat-item {
        color: #ccc;
        margin: 0.25rem 0;
      }

      .health-ko {
        color: #ff4444;
      }

      .health-critical {
        color: #ff8800;
      }

      .health-warning {
        color: #ffbb33;
      }

      .health-good {
        color: #00c851;
      }

      #endReason {
        color: #ffd700;
        font-size: 1.2rem;
        margin: 1rem 0;
        padding: 0.5rem;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 0.5rem;
      }

      #quitGame {
        background: #ff4444;
        color: white;
        border: none;
        padding: 1rem 2rem;
        font-size: 1.2rem;
        border-radius: 0.5rem;
        cursor: pointer;
        transition: background-color 0.3s;
        margin-top: 2rem;
      }

      #quitGame:hover {
        background: #cc0000;
      }
    </style>
  </head>
  <body>
    <h1>Victorryan - Jeu de cartes</h1>

    <!-- Écran initial -->
    <div id="homeScreen">
      <button id="createGameBtn">Créer une partie</button>
      <hr />
      <div>
        <h3>Rejoindre une partie</h3>
        <input type="text" id="playerNameInput" placeholder="Votre nom" />
        <input type="text" id="gameIdInput" placeholder="ID de la partie" />
        <button id="joinGameBtn">Rejoindre</button>
      </div>
    </div>

    <!-- Écran de création de partie -->
    <div id="createdGameScreen" class="hidden">
      <h2>Partie créée!</h2>
      <p>Partagez cet ID avec votre adversaire:</p>
      <div class="game-id">
        <span id="gameIdDisplay"></span>
        <button id="copyGameIdBtn">Copier</button>
      </div>
      <div>
        <input type="text" id="creatorNameInput" placeholder="Votre nom" />
        <button id="joinAsCreatorBtn">Rejoindre en tant que créateur</button>
      </div>
    </div>

    <!-- Écran d'attente -->
    <div id="waitingScreen" class="hidden">
      <h2>En attente...</h2>
      <p id="waitingMessage">En attente d'un adversaire</p>
    </div>

    <!-- Écran de jeu -->
    <div id="gameScreen" class="hidden">
      <div class="game-status" id="gameStatus">En attente...</div>

      <div class="game-info">
        <h3>Informations de la partie</h3>
        <div id="gameInfo">
          <p>
            Votre tour:
            <span id="turnIndicator" class="turn-indicator">En attente...</span>
          </p>
          <p>Joueur 1: <span id="player1Name"></span></p>
          <p>Joueur 2: <span id="player2Name"></span></p>
        </div>
      </div>

      <div class="player-section">
        <h3>Vos personnages</h3>
        <div class="cards-container" id="yourCharacters"></div>
      </div>

      <div class="player-section">
        <h3>Vos bonus</h3>
        <div class="cards-container" id="yourBonus"></div>
      </div>

      <div class="player-section">
        <h3>Personnages adverses</h3>
        <div class="cards-container" id="opponentCharacters"></div>
      </div>

      <div class="action-buttons hidden" id="actionButtons">
        <button id="attackBtn" class="action-button attack-button">
          <svg width="16" height="16" viewBox="0 0 512 512" fill="currentColor">
            <path
              d="M320 146c12.9 0 24.8 3.9 34.8 10.4 10.8 7.1 19.4 17.2 24.8 29.5 6.5 15 5.8 28.1 3.8 36.9-2.3 10.2-7.5 17.5-11.8 22.8-5.2 6.4-11.6 12-18.7 16.6-2.8 1.8-5.7 3.5-8.7 5-4.5 2.3-9.2 4.2-14 5.7L313 401.2c-1.7 10.1-10.4 17.5-20.8 17.5-5.4 0-10.4-2-14.2-5.4-3.5-3.2-5.9-7.5-6.5-12.3l-10.4-84.9-5.2 .7c-10 1.3-19.6-5.9-21.6-15.7l-7.1-35.5c-1.9-9.6 4.1-18.9 13.5-21.5l46.2-12.6-22-6.1c-9.1-2.5-15.1-10.9-14.5-19.9 .6-9.2 7.5-16.7 16.3-19h.3l14.6-3.5L299.8 172c-10.1-2-16.7-11.6-15-21.4 1.3-8 7.3-14.3 14.9-16.2 .7-.2 1.5-.3 2.3-.4h13.7 4.3zm-83.8 198L233 381.7c-3 35.4-32.9 62.3-68.5 62.3-22.1 0-41.8-10.5-54.3-26.7L32.7 323.9C11.4 296.3 .3 262.4 3.1 228.2S22.6 164.8 49.2 142c13.3-11.4 31.4-14.9 47.8-9.1 14.2 5 25.2 16.2 30 30.4l9 27.1c3.3 9.8 13.9 15.2 23.7 11.9s15.1-13.9 11.9-23.7l-9-27.1c-8.6-25.8-27.6-45.5-51.8-54.9-25.3-9.8-53.1-6.7-75.9 8.4l-1.1 .7c-36.3 31-59.2 75.7-63.7 124.8s10.3 97.8 40.2 138.1l77.5 93.5c21.4 25.8 53.2 40.8 87.2 40.8 59.5 0 108.2-45.3 113.9-103.7l5.8-59.1-18.8-1.1c-10.5-.6-18.5-9.5-18-20zm276-25.6L444.1 351c-18.3 14.2-40.2 21.4-62.2 21.1-21.6-.3-40.6-7.8-53.3-21.6l-5.7-6.2c-7.1-7.7-6.6-19.8 1.2-26.9s19.8-6.6 26.9 1.2l5.7 6.2c6.9 7.5 16.9 11.2 29.2 11.4 12.5 .2 25.4-3.6 35.7-11.6l68.6-53.1-11.7-15-69.8 54.1c-.2 .2-.4 .3-.5 .5-2.5 2.5-5.9 3.8-9.3 3.7-3.1-.1-6.2-1.5-8.4-3.8l-58.7-63.7c-5.5-5.9-11.8-8.5-16.1-9.5l7.4 35.2 118.9-15.9c5.9-.8 11.8 1.1 16.4 5.1s7.1 9.9 7.1 16v13.4c0 8.4-5.5 15.9-13.6 18.4zM445.8 266.7c-11.5 1.5-21.4-6.5-22.9-18s6.5-21.4 18-22.9l58.1-7.8c6.1-.8 11.3 1.3 14.9 5.3s5.2 9.5 4.3 14.4c-1.5 8.4-7.8 14.5-16.1 15.6l-56.3 13.4z"
            />
          </svg>
          Attaquer
        </button>
        <button id="playBonusBtn" class="action-button bonus-button">
          <svg width="16" height="16" viewBox="0 0 576 512" fill="currentColor">
            <path
              d="M400 0H176c-26.5 0-48.1 21.8-47.1 48.2c.2 5.3 .4 10.6 .7 15.8H24C10.7 64 0 74.7 0 88c0 92.6 33.5 157 78.5 200.7c44.3 43.1 98.3 64.8 138.1 75.8c23.4 6.5 39.4 26 39.4 45.6c0 20.9-17 37.9-37.9 37.9H192c-17.7 0-32 14.3-32 32s14.3 32 32 32H384c17.7 0 32-14.3 32-32s-14.3-32-32-32H357.9C337 448 320 431 320 410.1c0-19.6 15.9-39.2 39.4-45.6c39.9-11 93.9-32.7 138.2-75.8C542.5 245 576 180.6 576 88c0-13.3-10.7-24-24-24H446.4c.3-5.2 .5-10.4 .7-15.8C448.1 21.8 426.5 0 400 0zM48.9 112h84.4c9.1 90.1 29.2 150.3 51.9 190.6c-24.9-11-50.8-26.5-73.2-48.3c-32-31.1-58-76-63-142.3zM464.1 254.3c-22.4 21.8-48.3 37.3-73.2 48.3c22.7-40.3 42.8-100.5 51.9-190.6h84.4c-5.1 66.3-31.1 111.2-63 142.3z"
            />
          </svg>
          Jouer bonus
        </button>
      </div>
    </div>

    <!-- Écran de fin de partie -->
    <div id="gameOverScreen" class="hidden">
      <h2 id="gameOverTitle"></h2>
      <p id="gameOverMessage"></p>
      <div id="playerStats">
        <h3>Statistiques de la partie</h3>
        <div id="playerStatsContent"></div>
        <div id="gameEndReason" class="game-end-reason"></div>
      </div>
      <button id="quitGameBtn" class="btn btn-primary mt-3">
        Retour au menu
      </button>
    </div>

    <div id="messages"></div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // DOM Elements
        const screens = {
          home: document.getElementById("homeScreen"),
          created: document.getElementById("createdGameScreen"),
          waiting: document.getElementById("waitingScreen"),
          game: document.getElementById("gameScreen"),
        };

        const createGameBtn = document.getElementById("createGameBtn");
        const joinGameBtn = document.getElementById("joinGameBtn");
        const joinAsCreatorBtn = document.getElementById("joinAsCreatorBtn");
        const gameIdDisplay = document.getElementById("gameIdDisplay");
        const copyGameIdBtn = document.getElementById("copyGameIdBtn");
        const gameStatus = document.getElementById("gameStatus");
        const attackBtn = document.getElementById("attackBtn");
        const playBonusBtn = document.getElementById("playBonusBtn");
        const messages = document.getElementById("messages");

        // DOM Elements pour les cartes
        const yourCharacters = document.getElementById("yourCharacters");
        const yourBonus = document.getElementById("yourBonus");
        const opponentCharacters =
          document.getElementById("opponentCharacters");

        // Game State
        const gameState = {
          game: null,
          selectedCharacter: null,
          selectedBonus: null,
          targetCharacter: null,
          bonusPlayedThisTurn: false,
          lastBonusTarget: null,
          currentTurnNumber: 1,
          bonusActionsRemaining: 2, // Ajout du compteur de bonus restants
        };

        // Socket.io
        const socket = io();

        // Ajoutez ces variables DOM au début de votre code JavaScript
        const gameOverScreen = document.getElementById("gameOverScreen");
        const gameOverTitle = document.getElementById("gameOverTitle");
        const gameOverMessage = document.getElementById("gameOverMessage");
        const playerStats = document.getElementById("playerStats");
        const quitGameBtn = document.getElementById("quitGameBtn");

        // Functions
        function showScreen(screenName) {
          Object.keys(screens).forEach((key) => {
            screens[key].classList.add("hidden");
          });
          screens[screenName].classList.remove("hidden");
        }

        function showMessage(text, isError = false) {
          // Ne pas afficher de messages sur la page d'accueil
          const currentScreen = document.querySelector("div:not(.hidden)").id;
          if (currentScreen === "homeScreen") {
            return;
          }

          const messageContainer = document.createElement("div");
          messageContainer.style.position = "fixed";
          messageContainer.style.bottom = "20px";
          messageContainer.style.left = "50%";
          messageContainer.style.transform = "translateX(-50%)";
          messageContainer.style.padding = "12px 24px";
          messageContainer.style.backgroundColor = isError
            ? "rgba(244, 67, 54, 0.85)"
            : "rgba(76, 175, 80, 0.85)";
          messageContainer.style.color = "white";
          messageContainer.style.borderRadius = "4px";
          messageContainer.style.fontSize = "14px";
          messageContainer.style.zIndex = "100";
          messageContainer.style.maxWidth = "80%";
          messageContainer.style.textAlign = "center";
          messageContainer.style.boxShadow = "0 2px 5px rgba(0,0,0,0.2)";
          messageContainer.style.opacity = "0";
          messageContainer.style.transition = "opacity 0.3s ease-in-out";
          messageContainer.textContent = text;

          // Supprimer les anciens messages
          const oldMessages = document.querySelectorAll(
            "[data-message-container]"
          );
          oldMessages.forEach((msg) => {
            if (document.body.contains(msg)) {
              document.body.removeChild(msg);
            }
          });

          messageContainer.setAttribute("data-message-container", "true");
          document.body.appendChild(messageContainer);

          // Animation d'apparition
          requestAnimationFrame(() => {
            messageContainer.style.opacity = "1";
          });

          // Disparition progressive
          setTimeout(() => {
            messageContainer.style.opacity = "0";
            setTimeout(() => {
              if (document.body.contains(messageContainer)) {
                document.body.removeChild(messageContainer);
              }
            }, 300);
          }, 2000);
        }

        // Ajouter cette fonction pour vérifier si le joueur courant peut jouer
        function currentPlayerCanPlay() {
          if (!gameState.game || !gameState.isMyTurn) return false;

          const player = gameState.game.players[gameState.playerId];
          if (!player) return false;

          // Vérifier si au moins un personnage est vivant et a des tours d'attaque
          return Object.values(player.charactersState).some(
            (char) => char.currentHealth > 0 && char.currentTurns > 0
          );
        }

        // Fonction pour afficher les cartes des joueurs
        function renderCards() {
          if (!gameState.game || !gameState.game.players) return;

          // Synchroniser les valeurs du serveur et du client
          for (const playerId in gameState.game.players) {
            const player = gameState.game.players[playerId];

            // Parcourir tous les personnages du joueur
            if (player.charactersState) {
              for (const charId in player.charactersState) {
                const serverState = player.charactersState[charId];

                // S'assurer que les valeurs client existent
                if (
                  serverState.pointsdevie !== undefined &&
                  serverState.currentHealth === undefined
                ) {
                  serverState.currentHealth = serverState.pointsdevie;
                }

                if (
                  serverState.forceattaque !== undefined &&
                  serverState.currentAttack === undefined
                ) {
                  serverState.currentAttack = serverState.forceattaque;
                }

                if (
                  serverState.tourattaque !== undefined &&
                  serverState.currentTurns === undefined
                ) {
                  serverState.currentTurns = serverState.tourattaque;
                }

                // Garder les deux jeux de valeurs synchronisés
                serverState.currentHealth = serverState.pointsdevie;
                serverState.currentAttack = serverState.forceattaque;
                serverState.currentTurns = serverState.tourattaque;
              }
            }
          }

          const game = gameState.game;
          const player = game.players[gameState.playerId];

          if (!player || !player.cards) {
            console.log("Données du joueur non disponibles");
            return;
          }

          // Si c'est notre tour mais qu'on ne peut pas jouer, passer le tour automatiquement
          if (
            gameState.isMyTurn &&
            !currentPlayerCanPlay() &&
            !game.attackPerformed
          ) {
            // Trouver l'adversaire
            let opponent = null;
            for (const id in game.players) {
              if (id !== gameState.playerId) {
                opponent = game.players[id];
                break;
              }
            }

            // Vérifier si l'adversaire peut jouer
            const opponentCanPlay =
              opponent &&
              Object.values(opponent.charactersState).some(
                (char) => char.currentHealth > 0 && char.currentTurns > 0
              );

            if (opponentCanPlay) {
              // Si l'adversaire peut jouer, passer le tour
              showMessage(
                "Vous ne pouvez plus attaquer avec aucun personnage. Passage de tour automatique."
              );

              socket.emit("endTurn", {
                gameId: gameState.game.id,
                playerId: gameState.playerId,
              });

              // Pour éviter des émissions multiples
              game.attackPerformed = true;
            } else {
              // Si personne ne peut jouer, fin de partie
              // Ne vérifier la fin de partie que si le jeu est en cours depuis au moins un tour
              if (gameState.currentTurnNumber > 1) {
                checkGameOver();
              }
            }
          }

          // Si nous sommes en train d'attendre que l'attaque soit traitée, désactiver toutes les interactions
          const attackInProgress = gameState.isMyTurn && game.attackPerformed;

          // Trouver l'adversaire
          let opponent = null;
          for (const id in game.players) {
            if (id !== gameState.playerId) {
              opponent = game.players[id];
              break;
            }
          }

          // Afficher vos cartes personnages
          yourCharacters.innerHTML = "";
          if (player.cards.personnages) {
            player.cards.personnages.forEach((card) => {
              const characterState = player.charactersState[card.id];
              const cardEl = createCharacterCard(card, characterState, false);

              // Simplification de la condition pour ajouter l'événement de clic
              // C'est mon tour ET le personnage est vivant ET il a des tours d'attaque ET je n'ai pas encore attaqué
              const canAttack =
                gameState.isMyTurn &&
                characterState &&
                characterState.currentHealth > 0 &&
                characterState.currentTurns > 0 &&
                !game.attackPerformed;

              if (canAttack) {
                cardEl.addEventListener("click", () =>
                  selectYourCharacter(card.id)
                );
                cardEl.classList.add("can-attack");
              } else if (
                characterState &&
                (characterState.currentHealth <= 0 ||
                  characterState.currentTurns <= 0)
              ) {
                cardEl.classList.add("cannot-attack");
              }

              if (card.id === gameState.selectedCharacter) {
                cardEl.classList.add("selected");
              }

              yourCharacters.appendChild(cardEl);
            });
          }

          // Afficher vos cartes bonus
          yourBonus.innerHTML = "";
          player.cards.bonus.forEach((card) => {
            const cardEl = createBonusCard(card);

            // N'ajouter l'événement de clic que si le bonus a encore des tours et qu'on est notre tour
            const bonusTours = parseInt(card.tourbonus) || 0;

            // Vérifier si la carte bonus est utilisable (tourbonus > 0 et c'est notre tour)
            if (gameState.isMyTurn && bonusTours > 0) {
              cardEl.addEventListener("click", () => selectBonus(card.id));
              cardEl.classList.add("can-play");
            } else if (bonusTours <= 0) {
              cardEl.classList.add("depleted");
              // Ajouter un indicateur visuel que la carte est épuisée
              const depletedOverlay = document.createElement("div");
              depletedOverlay.className = "depleted-overlay";
              depletedOverlay.textContent = "Épuisée";
              cardEl.appendChild(depletedOverlay);
            }

            if (card.id === gameState.selectedBonus) {
              cardEl.classList.add("selected");
            }

            yourBonus.appendChild(cardEl);
          });

          // Afficher les cartes personnages de l'adversaire
          opponentCharacters.innerHTML = "";
          if (opponent && opponent.cards) {
            opponent.cards.personnages.forEach((card) => {
              const characterState = opponent.charactersState[card.id];
              const cardEl = createCharacterCard(card, characterState, true);

              // N'ajouter l'événement de clic que si le personnage est vivant
              if (
                gameState.isMyTurn &&
                gameState.selectedCharacter &&
                characterState &&
                characterState.currentHealth > 0
              ) {
                cardEl.addEventListener("click", () =>
                  selectOpponentCharacter(card.id)
                );
                cardEl.classList.add("can-target");
              }

              if (card.id === gameState.targetCharacter) {
                cardEl.classList.add("selected");
              }

              opponentCharacters.appendChild(cardEl);
            });
          }

          // Mettre à jour les boutons d'action
          updateActionButtons();

          // Si une attaque est en cours de traitement, ajouter une indication visuelle
          if (attackInProgress) {
            const message = document.createElement("div");
            message.className = "turn-info";
            message.textContent = "Changement de tour en cours...";
            message.style.position = "fixed";
            message.style.top = "50%";
            message.style.left = "50%";
            message.style.transform = "translate(-50%, -50%)";
            message.style.zIndex = "1000";
            message.style.padding = "20px";
            message.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
            message.style.color = "white";
            message.style.borderRadius = "8px";

            // Supprimer les anciennes notifications si elles existent
            const existingMessages = document.querySelectorAll(".turn-info");
            existingMessages.forEach((m) => m.remove());

            document.body.appendChild(message);

            // Supprimer après un court délai
            setTimeout(() => {
              message.remove();
            }, 2000);
          }
        }

        function createCharacterCard(card, state, isOpponent) {
          const cardEl = document.createElement("div");
          cardEl.className = `card ${
            isOpponent ? "opponent-card" : "personnage-card"
          }`;
          cardEl.dataset.id = card.id;

          // Récupérer les valeurs correctes
          // Si state existe, prendre currentHealth ou pointsdevie
          // Sinon, prendre pointsdevie de la carte ou 100 par défaut
          const health = state
            ? state.currentHealth !== undefined
              ? state.currentHealth
              : state.pointsdevie || 100
            : card.pointsdevie
            ? parseInt(card.pointsdevie)
            : 100;

          const attack = state
            ? state.currentAttack !== undefined
              ? state.currentAttack
              : state.forceattaque || 30
            : card.forceattaque
            ? parseInt(card.forceattaque)
            : 30;

          const turns = state
            ? state.currentTurns !== undefined
              ? state.currentTurns
              : state.tourattaque || 2
            : card.tourattaque
            ? parseInt(card.tourattaque)
            : 2;

          // Vérifier si des bonus sont actifs
          const activeBonus =
            state && state.activeBonus ? state.activeBonus : [];

          // Créer l'élément d'image
          let imageHtml = "";
          if (card.fond) {
            imageHtml = `<div class="card-image" style="background-image: url('${card.fond}')"></div>`;
          }

          // Indicateur de bonus actifs
          const bonusIndicator =
            activeBonus.length > 0
              ? `<div class="active-bonus-indicator">${activeBonus.length}</div>`
              : "";

          // Déterminer la classe de santé
          let healthClass = "normal";
          if (health <= 0) {
            healthClass = "depleted";
          } else if (health <= 30) {
            healthClass = "critical";
          } else if (health <= 50) {
            healthClass = "warning";
          }

          let healthDisplay = health;
          if (health <= 0) {
            healthDisplay = "KO";
          }

          // Construire le HTML de la carte simplifiée avec icônes
          cardEl.innerHTML = `
            ${imageHtml}
            ${bonusIndicator}
            <div style="position: absolute; top: 8px; left: 5px; right: 5px; z-index: 3; display: flex; flex-wrap: wrap; gap: 4px;">
              <div class="stat-item stat-hp"><span class="health-${healthClass}">${healthDisplay}</span></div>
              <div class="stat-item stat-attack">${attack}</div>
              <div class="stat-item stat-turns">${turns}</div>
            </div>
          `;

          return cardEl;
        }

        function createBonusCard(card) {
          const cardEl = document.createElement("div");
          cardEl.className = "card bonus-card";
          cardEl.dataset.id = card.id;

          // Ajouter la classe 'depleted' si le bonus n'a plus de tours
          if (parseInt(card.tourbonus) <= 0 || card.disabled) {
            cardEl.classList.add("depleted");
          }

          // Créer l'élément d'image
          let imageHtml = "";
          if (card.fond) {
            imageHtml = `<div class="card-image" style="background-image: url('${card.fond}')"></div>`;
          }

          // Récupérer les valeurs correctes
          const pourcentage = card.pourcentagebonus
            ? parseInt(card.pourcentagebonus)
            : 0;
          const tours = card.tourbonus ? parseInt(card.tourbonus) : 0;

          // Construire le HTML de la carte simplifiée avec icônes
          cardEl.innerHTML = `
            ${imageHtml}
            <div style="position: absolute; top: 8px; left: 5px; right: 5px; z-index: 3; display: flex; flex-wrap: wrap; gap: 4px;">
              <div class="stat-item stat-bonus">+${pourcentage}%</div>
              <div class="stat-item stat-turns">${tours}</div>
            </div>
          `;

          return cardEl;
        }

        function selectYourCharacter(cardId) {
          if (!gameState.isMyTurn) return;

          // Récupérer l'état du personnage
          const characterState =
            gameState.game.players[gameState.playerId].charactersState[cardId];

          // Vérifier si le personnage est KO ou n'a plus de tours
          if (characterState && characterState.currentHealth <= 0) {
            showMessage(
              "Ce personnage est KO et ne peut pas être sélectionné",
              true
            );
            return;
          }

          if (characterState && characterState.currentTurns <= 0) {
            showMessage(
              "Ce personnage n'a plus de tours d'attaque disponibles",
              true
            );
            return;
          }

          // Si un bonus a été joué ce tour-ci
          if (gameState.bonusPlayedThisTurn) {
            // On ne peut sélectionner que le personnage qui a reçu le bonus ce tour-ci
            if (cardId === gameState.lastBonusTarget) {
              gameState.selectedCharacter =
                gameState.selectedCharacter === cardId ? null : cardId;
            } else {
              showMessage(
                `Vous ne pouvez sélectionner que le personnage auquel vous avez appliqué un bonus ce tour-ci`,
                true
              );
              return;
            }
          } else {
            // Si aucun bonus n'a été joué ce tour-ci, on peut sélectionner n'importe quel personnage valide
            gameState.selectedCharacter =
              gameState.selectedCharacter === cardId ? null : cardId;
          }

          // Réinitialiser la cible si on change de personnage attaquant
          gameState.targetCharacter = null;

          updateActionButtons();
          renderCards();
        }

        function selectOpponentCharacter(cardId) {
          if (!gameState.isMyTurn || !gameState.selectedCharacter) return;

          // Vérifier que le personnage cible est valide
          let opponent = null;
          for (const id in gameState.game.players) {
            if (id !== gameState.playerId) {
              opponent = gameState.game.players[id];
              break;
            }
          }

          if (!opponent || !opponent.charactersState[cardId]) {
            showMessage("Personnage cible non trouvé", true);
            return;
          }

          const targetState = opponent.charactersState[cardId];
          if (targetState.currentHealth <= 0) {
            showMessage("Ce personnage est déjà KO", true);
            return;
          }

          if (gameState.targetCharacter === cardId) {
            gameState.targetCharacter = null;
          } else {
            gameState.targetCharacter = cardId;
          }

          renderCards();
        }

        function selectBonus(cardId) {
          if (!gameState.isMyTurn) return;

          // Vérifier si on a encore des actions bonus disponibles
          if (gameState.bonusActionsRemaining <= 0) {
            showMessage(
              "Vous avez déjà utilisé vos 2 actions bonus ce tour-ci",
              true
            );
            return;
          }

          // Vérifier si le bonus est déjà sélectionné
          if (gameState.selectedBonus === cardId) {
            gameState.selectedBonus = null;
          } else {
            gameState.selectedBonus = cardId;
          }

          updateActionButtons();
          renderCards();
        }

        function updateActionButtons() {
          const actionButtons = document.getElementById("actionButtons");

          if (gameState.isMyTurn) {
            // Le bouton d'attaque est visible seulement si un personnage est sélectionné et une cible
            const canAttack =
              gameState.selectedCharacter && gameState.targetCharacter;
            attackBtn.style.display = canAttack ? "flex" : "none";

            // Le bouton pour jouer un bonus est visible seulement si un bonus et un personnage sont sélectionnés
            const canPlayBonus =
              gameState.selectedBonus && gameState.selectedCharacter;
            playBonusBtn.style.display = canPlayBonus ? "flex" : "none";

            // Si au moins un des boutons est visible, afficher le conteneur de boutons
            if (canAttack || canPlayBonus) {
              actionButtons.classList.remove("hidden");
            } else {
              actionButtons.classList.add("hidden");
            }
          } else {
            // Si ce n'est pas notre tour, cacher tous les boutons
            actionButtons.classList.add("hidden");
          }
        }

        // Modifier la fonction updateGameStatus pour afficher l'écran de fin quand la partie est terminée
        function updateGameStatus() {
          let statusText = "";

          if (gameState.game && gameState.game.status === "playing") {
            // S'assurer que le numéro de tour est défini
            if (typeof gameState.currentTurnNumber === "undefined") {
              // Si le serveur fournit un numéro de tour, l'utiliser
              if (gameState.game.turnNumber) {
                gameState.currentTurnNumber = gameState.game.turnNumber;
              } else {
                gameState.currentTurnNumber = 1;
              }
            }

            statusText = `<div class="turn-info">
              <span>${
                gameState.isMyTurn
                  ? "C'est votre tour!"
                  : "Au tour de l'adversaire"
              }</span>
              <span class="turn-number">Tour ${
                gameState.currentTurnNumber
              }</span>
            </div>`;

            // Ajouter l'information sur l'attaque
            if (gameState.isMyTurn) {
              const attackStatus =
                gameState.game && gameState.game.attackPerformed
                  ? '<span class="attack-status">Attaque effectuée</span>'
                  : '<span class="attack-status">Attaque disponible</span>';

              statusText += attackStatus;
            }
          } else if (gameState.game && gameState.game.status === "finished") {
            // Si la partie est terminée, afficher l'écran de fin de partie automatiquement
            if (gameState.game.winner === gameState.playerId) {
              statusText = "Victoire! La partie est terminée.";
              // Afficher l'écran de fin de partie avec un court délai pour que l'utilisateur voie le message
              setTimeout(() => {
                showGameOverScreen({
                  winner: gameState.playerId,
                  playersTotalHealth: gameState.game.playersTotalHealth || null,
                  newGameState: gameState.game,
                });
              }, 1500);
            } else if (gameState.game.winner) {
              statusText = "Défaite... La partie est terminée.";
              // Afficher l'écran de fin de partie avec un court délai
              setTimeout(() => {
                showGameOverScreen({
                  winner: gameState.game.winner,
                  playersTotalHealth: gameState.game.playersTotalHealth || null,
                  newGameState: gameState.game,
                });
              }, 1500);
            } else {
              statusText = "Partie terminée.";
            }
          } else if (gameState.game && gameState.game.status === "paused") {
            statusText = "Partie en pause - un joueur s'est déconnecté.";
          } else {
            statusText = "En attente de joueurs...";
          }

          gameStatus.innerHTML = statusText;
        }

        // Event handlers
        createGameBtn.addEventListener("click", () => {
          fetch("/api/games", {
            method: "POST",
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.success) {
                currentGameId = data.gameId;
                gameState.game = data.game;
                gameIdDisplay.textContent = data.gameId;
                showScreen("created");
              } else {
                showMessage("Erreur: " + data.error, true);
              }
            })
            .catch((error) => {
              showMessage("Erreur de connexion", true);
              console.error("Error:", error);
            });
        });

        joinGameBtn.addEventListener("click", () => {
          const name = document.getElementById("playerNameInput").value.trim();
          const gameId = document.getElementById("gameIdInput").value.trim();

          if (!name || !gameId) {
            showMessage("Nom et ID de partie requis", true);
            return;
          }

          joinGame(gameId, name);
        });

        joinAsCreatorBtn.addEventListener("click", () => {
          const name = document.getElementById("creatorNameInput").value.trim();

          if (!name) {
            showMessage("Nom requis", true);
            return;
          }

          if (!currentGameId) {
            showMessage("ID de partie non trouvé", true);
            return;
          }

          joinGame(currentGameId, name);
        });

        copyGameIdBtn.addEventListener("click", () => {
          navigator.clipboard
            .writeText(gameState.game.id)
            .then(() => showMessage("ID copié!"))
            .catch(() => showMessage("Erreur de copie", true));
        });

        attackBtn.addEventListener("click", () => {
          if (
            !gameState.isMyTurn ||
            !gameState.selectedCharacter ||
            !gameState.targetCharacter
          )
            return;

          // Vérification que le personnage a des tours d'attaque et est en vie
          const game = gameState.game;
          const player = game.players[gameState.playerId];
          const attacker = player.charactersState[gameState.selectedCharacter];

          if (attacker.currentHealth <= 0) {
            showMessage(
              "Ce personnage est vaincu et ne peut pas attaquer.",
              true
            );
            return;
          }

          if (attacker.currentTurns <= 0) {
            showMessage(
              "Ce personnage n'a plus de tours d'attaque disponibles.",
              true
            );
            return;
          }

          // Trouver les noms des cartes pour l'affichage
          const attackerCard = player.cards.personnages.find(
            (c) => c.id === gameState.selectedCharacter
          );
          const attackerName = attackerCard
            ? attackerCard.nomcarteperso
            : gameState.selectedCharacter;

          // Trouver l'adversaire et la carte cible
          let opponent = null;
          for (const id in game.players) {
            if (id !== gameState.playerId) {
              opponent = game.players[id];
              break;
            }
          }

          let targetName = gameState.targetCharacter;
          if (opponent) {
            const targetCard = opponent.cards.personnages.find(
              (c) => c.id === gameState.targetCharacter
            );
            if (targetCard) {
              targetName = targetCard.nomcarteperso;
            }
          }

          // Émettre l'événement d'attaque
          socket.emit("attack", {
            gameId: gameState.game.id,
            playerId: gameState.playerId,
            attackerId: gameState.selectedCharacter,
            targetId: gameState.targetCharacter,
          });

          // Informer le joueur que le tour passe automatiquement à l'adversaire
          showMessage(
            `${attackerName} attaque ${targetName}. Le tour passe à l'adversaire.`
          );

          // Mettre à jour l'interface pour le joueur
          gameState.isMyTurn = false; // Désactiver son tour en attendant la confirmation du serveur
          updateActionButtons();
          renderCards();
        });

        playBonusBtn.addEventListener("click", () => {
          if (
            !gameState.isMyTurn ||
            !gameState.selectedBonus ||
            !gameState.selectedCharacter
          )
            return;

          // Vérifier si on a encore des actions bonus disponibles
          if (gameState.bonusActionsRemaining <= 0) {
            showMessage(
              "Vous avez déjà utilisé vos 2 actions bonus ce tour-ci",
              true
            );
            return;
          }

          // Vérifier que le personnage cible existe et est valide
          const player = gameState.game.players[gameState.playerId];
          if (
            !player ||
            !player.charactersState ||
            !player.charactersState[gameState.selectedCharacter]
          ) {
            showMessage(
              "Erreur: Personnage cible non trouvé dans vos cartes",
              true
            );
            return;
          }

          const characterState =
            player.charactersState[gameState.selectedCharacter];
          if (characterState.currentHealth <= 0) {
            showMessage(
              "Ce personnage est KO et ne peut pas recevoir de bonus",
              true
            );
            return;
          }

          // Vérifier que la carte bonus existe
          const bonusCard = player.cards.bonus.find(
            (b) => b.id === gameState.selectedBonus
          );
          if (!bonusCard) {
            showMessage("Erreur: Carte bonus non trouvée", true);
            return;
          }

          // Vérifier que la carte personnage existe
          const characterCard = player.cards.personnages.find(
            (c) => c.id === gameState.selectedCharacter
          );
          if (!characterCard) {
            showMessage("Erreur: Carte personnage non trouvée", true);
            return;
          }

          console.log("Envoi du bonus:", {
            gameId: gameState.game.id,
            playerId: gameState.playerId,
            bonusId: gameState.selectedBonus,
            targetId: gameState.selectedCharacter,
          });

          socket.emit("playBonus", {
            gameId: gameState.game.id,
            playerId: gameState.playerId,
            bonusId: gameState.selectedBonus,
            targetId: gameState.selectedCharacter,
          });

          // Décrémenter le compteur d'actions bonus
          gameState.bonusActionsRemaining--;

          // Afficher un message explicite avec le nombre d'actions bonus restantes
          showMessage(
            `Tour ${gameState.currentTurnNumber}: ${
              bonusCard.nomcartebonus || "Bonus"
            } joué sur ${
              characterCard.nomcarteperso || gameState.selectedCharacter
            } (${gameState.bonusActionsRemaining} action${
              gameState.bonusActionsRemaining > 1 ? "s" : ""
            } bonus restante${gameState.bonusActionsRemaining > 1 ? "s" : ""})`
          );

          // Réinitialiser seulement la sélection de bonus, garder le personnage sélectionné
          gameState.selectedBonus = null;
          renderCards();
        });

        // Game functions
        function joinGame(gameId, playerName) {
          showScreen("waiting");
          document.getElementById("waitingMessage").textContent =
            "Connexion en cours...";

          fetch(`/api/games/${gameId}/join`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name: playerName }),
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.success) {
                gameState.game = data.game;
                gameState.playerId = data.playerId;
                gameState.playerName = playerName;
                currentGameId = data.gameId;
                currentPlayerId = data.playerId;

                // Sauvegarder dans localStorage
                localStorage.setItem("gameId", data.gameId);
                localStorage.setItem("playerId", data.playerId);
                localStorage.setItem("playerName", playerName);

                // Connexion socket
                document.getElementById("waitingMessage").textContent =
                  "En attente d'un adversaire...";
                socket.emit("joinRoom", {
                  gameId: data.gameId,
                  playerId: data.playerId,
                  playerName: playerName,
                });
              } else {
                showMessage("Erreur: " + data.error, true);
                showScreen("home");
              }
            })
            .catch((error) => {
              showMessage("Erreur de connexion", true);
              showScreen("home");
              console.error("Error:", error);
            });
        }

        // Gestionnaires d'événements pour la déconnexion/reconnexion
        function setupConnectionHandlers() {
          // Gérer la déconnexion d'un joueur
          socket.on("playerLeft", (data) => {
            console.log("Joueur déconnecté:", data);
            if (data.temporary) {
              showMessage(
                `${data.playerName} s'est déconnecté temporairement. La partie est en pause.`,
                true
              );
            } else {
              showMessage(`${data.playerName} a quitté la partie.`, true);
            }
          });

          // Gérer la mise en pause de la partie
          socket.on("gamePaused", (data) => {
            console.log("Partie en pause:", data);
            if (data.reason === "player_disconnected") {
              showMessage(
                `La partie est en pause car ${data.playerName} s'est déconnecté. Attente de reconnexion...`,
                true
              );
              disableGameInteractions();
            }

            if (data.newGameState) {
              gameState.game = data.newGameState;
              updateGameStatus();
              renderCards();
            }
          });

          // Gérer la reprise de la partie
          socket.on("gameResumed", (data) => {
            console.log("Partie reprise:", data);
            showMessage(
              `${data.playerName} s'est reconnecté. La partie reprend !`
            );
            enableGameInteractions();

            if (data.newGameState) {
              gameState.game = data.newGameState;
              updateGameStatus();
              renderCards();
            }
          });

          // Gérer la déconnexion du socket
          socket.on("disconnect", () => {
            console.log("Déconnecté du serveur");
            showMessage(
              "Déconnecté du serveur. Tentative de reconnexion...",
              true
            );
            disableGameInteractions();
          });

          // Gérer la reconnexion du socket
          socket.on("connect", () => {
            console.log("Reconnecté au serveur");
            if (gameState.game && gameState.playerId) {
              socket.emit("reconnectToGame", {
                gameId: gameState.game.id,
                playerId: gameState.playerId,
              });
            }
          });

          // Gérer la fin de partie par abandon
          socket.on("gameOver", (data) => {
            console.log("Événement gameOver reçu:", data);

            // Désactiver toutes les interactions de jeu
            disableGameInteractions();

            // S'assurer que nous avons toutes les données nécessaires
            if (!data || !data.newGameState) {
              console.error("Données de fin de partie invalides:", data);
              return;
            }

            // Mettre à jour l'état du jeu avec les dernières données
            gameState.game = data.newGameState;

            // Calculer les statistiques pour chaque joueur
            const playerStats = {};
            const playersTotalHealth = {};

            // Pour chaque joueur dans la partie
            Object.entries(gameState.game.players).forEach(
              ([playerId, player]) => {
                const stats = {
                  totalHealth: 0,
                  koCharactersCount: 0,
                  canAttack: false,
                };

                // Calculer les statistiques
                if (player.charactersState) {
                  Object.values(player.charactersState).forEach((char) => {
                    stats.totalHealth += Math.max(
                      0,
                      char.currentHealth || char.pointsdevie || 0
                    );
                    if (char.currentHealth <= 0 || char.pointsdevie <= 0) {
                      stats.koCharactersCount++;
                    }
                    if (
                      (char.currentHealth > 0 || char.pointsdevie > 0) &&
                      (char.currentTurns > 0 || char.tourattaque > 0)
                    ) {
                      stats.canAttack = true;
                    }
                  });
                }

                playerStats[playerId] = stats;
                playersTotalHealth[playerId] = stats.totalHealth;
              }
            );

            // Afficher immédiatement l'écran de fin de partie avec les statistiques
            showGameOverScreen({
              winner: data.winner,
              playersTotalHealth: playersTotalHealth,
              newGameState: gameState.game,
              reason: data.reason,
              playerStats: playerStats,
            });
          });
        }

        // Fonctions utilitaires
        function disableGameInteractions() {
          document.querySelectorAll(".btn, .card").forEach((el) => {
            el.style.pointerEvents = "none";
            el.style.opacity = "0.7";
          });
        }

        function enableGameInteractions() {
          document.querySelectorAll(".btn, .card").forEach((el) => {
            el.style.pointerEvents = "auto";
            el.style.opacity = "1";
          });
        }

        // Initialisation
        setupConnectionHandlers();

        socket.on("connect", () => {
          console.log("Connecté au serveur");
        });

        socket.on("error", (data) => {
          showMessage("Erreur: " + data.message, true);
        });

        socket.on("gameState", (data) => {
          console.log("État du jeu reçu:", data);

          if (!data.game) {
            showMessage("Erreur: État du jeu invalide", true);
            return;
          }

          gameState.game = data.game;
          gameState.playerId = data.playerId;
          gameState.isMyTurn = data.game.currentTurn === data.playerId;
          gameState.currentTurnNumber = gameState.game.turnNumber || 1;

          // Initialiser les variables de sélection
          gameState.selectedCharacter = null;
          gameState.selectedBonus = null;
          gameState.targetCharacter = null;

          // Synchroniser les valeurs du serveur et du client
          if (gameState.game && gameState.game.players) {
            for (const playerId in gameState.game.players) {
              const player = gameState.game.players[playerId];

              // Parcourir tous les personnages du joueur
              if (player.charactersState) {
                for (const charId in player.charactersState) {
                  const serverState = player.charactersState[charId];

                  // Initialiser les valeurs client à partir des valeurs serveur
                  serverState.currentHealth = serverState.pointsdevie;
                  serverState.currentAttack = serverState.forceattaque;
                  serverState.currentTurns = serverState.tourattaque;

                  // Initialiser activeBonus s'il n'existe pas
                  if (!serverState.activeBonus) {
                    serverState.activeBonus = [];
                  }
                }
              }
            }
          }

          // Si on est reconnecté, afficher un message
          if (data.reconnected) {
            showMessage("Vous êtes reconnecté à la partie");
          }

          // Afficher l'écran de jeu et mettre à jour l'interface
          showScreen("gameScreen");
          updateGameStatus();
          updateActionButtons();
          renderCards();
        });

        socket.on("playerJoined", function (data) {
          if (data && data.playerId && data.playerName) {
            displayMessage(`${data.playerName} a rejoint la partie !`);
            if (typeof updateGameState === "function") {
              updateGameState();
            }
          }
        });

        socket.on("gameReady", (data) => {
          console.log("Partie prête:", data);
          gameState.game = data.game;
          gameState.isMyTurn = data.startingPlayer === gameState.playerId;

          // Initialiser le compteur de tour global
          if (!gameState.currentTurnNumber) {
            gameState.currentTurnNumber = 1;
          }
          console.log("Tour initial:", gameState.currentTurnNumber);

          // S'assurer que l'état initial des personnages est correctement initialisé
          const player = gameState.game.players[gameState.playerId];
          if (player && player.charactersState) {
            Object.values(player.charactersState).forEach((char) => {
              if (char.currentHealth === undefined) {
                char.currentHealth = char.pointsdevie || 100;
              }
              if (char.currentTurns === undefined) {
                char.currentTurns = char.tourattaque || 2;
              }
              if (char.currentAttack === undefined) {
                char.currentAttack = char.forceattaque || 30;
              }
            });
          }

          showScreen("game");
          updateGameStatus();
          renderCards();

          showMessage("La partie commence!");
        });

        socket.on("turnChanged", (data) => {
          console.log("Changement de tour:", data);

          // Récupérer l'état précédent
          const previousTurn = gameState.isMyTurn;

          // Mettre à jour l'état de tour actuel
          gameState.isMyTurn = data.currentTurn === gameState.playerId;

          // Mettre à jour l'état du jeu avec les données du serveur
          if (data.newGameState) {
            gameState.game = data.newGameState;

            // Mettre à jour le numéro de tour depuis le serveur si disponible
            if (gameState.game.turnNumber) {
              gameState.currentTurnNumber = gameState.game.turnNumber;
            }
            // Sinon, incrémenter localement si le tour passe de l'adversaire à nous
            else if (gameState.isMyTurn && !previousTurn) {
              gameState.currentTurnNumber =
                (gameState.currentTurnNumber || 1) + 1;
            }

            // Réinitialiser les flags d'action
            if (gameState.game) {
              gameState.game.attackPerformed = false;
              // Stocker les flags de bonus dans l'état du jeu
              gameState.bonusPlayedThisTurn = false;
              gameState.lastBonusTarget = null;
              // Réinitialiser le compteur d'actions bonus
              gameState.bonusActionsRemaining = 2;
            }
          }

          // Réinitialiser les sélections au début de notre tour
          if (gameState.isMyTurn) {
            gameState.selectedCharacter = null;
            gameState.selectedBonus = null;
            gameState.targetCharacter = null;

            showMessage(
              `Tour ${gameState.currentTurnNumber}: C'est votre tour! Vous pouvez sélectionner n'importe quel personnage et utiliser jusqu'à 2 actions bonus.`
            );
          } else {
            showMessage(
              `Tour ${gameState.currentTurnNumber}: Au tour de l'adversaire`
            );
          }

          showTurnChange(gameState.isMyTurn);
          updateGameStatus();
          updateActionButtons();
          renderCards();
        });

        socket.on("bonusPlayed", (data) => {
          if (!gameState.game) return;

          // Si le serveur nous a envoyé un nouvel état du jeu, l'utiliser
          if (data.newGameState) {
            gameState.game = data.newGameState;

            // Synchroniser les valeurs client et serveur
            if (gameState.game && gameState.game.players) {
              // Pour chaque joueur
              for (const playerId in gameState.game.players) {
                const player = gameState.game.players[playerId];

                // Parcourir tous les personnages du joueur
                if (player.charactersState) {
                  for (const charId in player.charactersState) {
                    const serverState = player.charactersState[charId];

                    // Mettre à jour currentHealth, currentAttack et currentTurns
                    if (!serverState.currentHealth)
                      serverState.currentHealth = serverState.pointsdevie;
                    if (!serverState.currentAttack)
                      serverState.currentAttack = serverState.forceattaque;
                    if (!serverState.currentTurns)
                      serverState.currentTurns = serverState.tourattaque;

                    // Garder les deux jeux de valeurs synchronisés
                    serverState.currentHealth = serverState.pointsdevie;
                    serverState.currentAttack = serverState.forceattaque;
                    serverState.currentTurns = serverState.tourattaque;
                  }
                }
              }
            }

            // Marquer le bonus comme joué ce tour
            gameState.bonusPlayedThisTurn = true;
            gameState.lastBonusTarget = data.targetId;
          }

          // Afficher un message plus informatif
          const bonusName = data.bonusName || "Bonus";
          const targetName = data.targetName || data.targetId;
          const newAttack = data.newAttack || "?";
          showMessage(
            `${bonusName} appliqué sur ${targetName}. Nouvelle attaque: ${newAttack}`
          );

          // Mettre à jour l'affichage
          renderCards();
        });

        socket.on("characterAttacked", (data) => {
          if (!gameState.game) return;

          // Si le serveur nous a envoyé un nouvel état du jeu, l'utiliser
          if (data.newGameState) {
            gameState.game = data.newGameState;

            // Synchroniser les valeurs client et serveur
            if (gameState.game && gameState.game.players) {
              // Pour chaque joueur
              for (const playerId in gameState.game.players) {
                const player = gameState.game.players[playerId];

                // Parcourir tous les personnages du joueur
                if (player.charactersState) {
                  for (const charId in player.charactersState) {
                    const serverState = player.charactersState[charId];

                    // Mettre à jour currentHealth, currentAttack et currentTurns
                    if (!serverState.currentHealth)
                      serverState.currentHealth = serverState.pointsdevie;
                    if (!serverState.currentAttack)
                      serverState.currentAttack = serverState.forceattaque;
                    if (!serverState.currentTurns)
                      serverState.currentTurns = serverState.tourattaque;

                    // Garder les deux jeux de valeurs synchronisés
                    serverState.currentHealth = serverState.pointsdevie;
                    serverState.currentAttack = serverState.forceattaque;
                    serverState.currentTurns = serverState.tourattaque;
                  }
                }
              }
            }

            // Marquer l'attaque comme effectuée ce tour
            gameState.game.attackPerformed = true;
          }

          // Afficher un message plus informatif
          const attackerName = data.attackerName || data.attackerId;
          const targetName = data.targetName || data.targetId;
          const damage = data.damage || "?";
          const newHealth = data.newHealth || "?";
          showMessage(
            `${attackerName} a attaqué ${targetName} pour ${damage} points de dégâts! Points de vie restants: ${newHealth}`
          );

          // Mettre à jour l'affichage
          renderCards();
        });

        // Ajoutez les gestionnaires d'événements pour les boutons de fin de partie
        quitGameBtn.addEventListener("click", returnToMenu);

        // Fonction pour retourner au menu principal
        function returnToMenu() {
          if (socket) {
            socket.emit("leaveGame", { gameId: currentGameId });
            socket.disconnect();
          }
          currentGameId = null;
          currentPlayerId = null;
          hideAllScreens();
          showScreen("menuScreen");
        }

        // Gestionnaire d'événement gameOver
        socket.on("gameOver", function (data) {
          console.log("Événement gameOver reçu:", data);

          // Désactiver les interactions de jeu SAUF le bouton de retour au menu
          document.querySelectorAll(".card, .action-button").forEach((el) => {
            el.style.pointerEvents = "none";
            el.style.opacity = "0.7";
          });

          // S'assurer que nous avons toutes les données nécessaires
          if (!data || !data.newGameState) {
            console.error("Données de fin de partie invalides:", data);
            return;
          }

          // Mettre à jour l'état du jeu avec les dernières données
          gameState.game = data.newGameState;

          // Calculer les statistiques pour chaque joueur
          const playerStats = {};
          const playersTotalHealth = {};

          // Pour chaque joueur dans la partie
          Object.entries(gameState.game.players).forEach(
            ([playerId, player]) => {
              const stats = {
                totalHealth: 0,
                koCharactersCount: 0,
                canAttack: false,
              };

              // Calculer les statistiques
              if (player.charactersState) {
                Object.values(player.charactersState).forEach((char) => {
                  stats.totalHealth += Math.max(
                    0,
                    char.currentHealth || char.pointsdevie || 0
                  );
                  if (char.currentHealth <= 0 || char.pointsdevie <= 0) {
                    stats.koCharactersCount++;
                  }
                  if (
                    (char.currentHealth > 0 || char.pointsdevie > 0) &&
                    (char.currentTurns > 0 || char.tourattaque > 0)
                  ) {
                    stats.canAttack = true;
                  }
                });
              }

              playerStats[playerId] = stats;
              playersTotalHealth[playerId] = stats.totalHealth;
            }
          );

          // Afficher immédiatement l'écran de fin de partie avec les statistiques
          showGameOverScreen({
            winner: data.winner,
            playersTotalHealth: playersTotalHealth,
            newGameState: gameState.game,
            reason: data.reason,
            playerStats: playerStats,
          });
        });

        // Fonction pour afficher l'écran de fin de partie
        function showGameOverScreen(data) {
          console.log("Affichage de l'écran de fin de partie:", data);

          // Masquer tous les écrans sauf l'écran de fin de partie
          hideAllScreens();
          const gameOverScreen = document.getElementById("gameOverScreen");
          gameOverScreen.classList.remove("hidden");

          // Mettre à jour le titre et le message
          const titleElement = document.getElementById("gameOverTitle");
          const messageElement = document.getElementById("gameOverMessage");
          const statsContent = document.getElementById("playerStatsContent");
          const reasonElement = document.getElementById("gameEndReason");

          // Déterminer le résultat
          let result;
          if (data.winner === "tie") {
            result = {
              title: "🤝 Match Nul !",
              message: "La partie est terminée.",
              titleClass: "game-over-title tie",
              messageClass: "message-tie",
            };
          } else if (data.winner === gameState.playerId) {
            result = {
              title: "🏆 Victoire !",
              message: "La partie est terminée.",
              titleClass: "game-over-title victory",
              messageClass: "message-victory",
            };
          } else {
            result = {
              title: "💔 Défaite",
              message: "La partie est terminée.",
              titleClass: "game-over-title defeat",
              messageClass: "message-defeat",
            };
          }

          // Appliquer le résultat
          titleElement.textContent = result.title;
          titleElement.className = result.titleClass;
          messageElement.textContent = result.message;
          messageElement.className = result.messageClass;

          // Afficher les statistiques
          statsContent.innerHTML = "";

          // Fonction pour créer un bloc de stats joueur
          const createPlayerStatBlock = (playerStats, playerName, isWinner) => {
            return `
              <div class="player-stat">
                <div class="player-stat-header">
                  <span class="player-name">${playerName}</span>
                  ${isWinner ? '<span class="winner-badge">🏆</span>' : ""}
                </div>
                <div class="player-stat-details">
                  <div class="stat-row">Points de vie restants: ${
                    playerStats.totalHealth
                  }</div>
                  <div class="stat-row">Personnages KO: ${
                    playerStats.koCharactersCount
                  }</div>
                  <div class="stat-row">Peut encore attaquer: ${
                    playerStats.canAttack ? "Oui" : "Non"
                  }</div>
                </div>
              </div>
            `;
          };

          // Afficher les stats des deux joueurs
          const currentPlayerStats = data.playerStats[gameState.playerId];
          const currentPlayer = data.newGameState.players[gameState.playerId];
          if (currentPlayer && currentPlayerStats) {
            statsContent.innerHTML += createPlayerStatBlock(
              currentPlayerStats,
              currentPlayer.name || "Vous",
              data.winner === gameState.playerId
            );
          }

          const opponentId = Object.keys(data.newGameState.players).find(
            (id) => id !== gameState.playerId
          );
          const opponentStats = data.playerStats[opponentId];
          const opponent = data.newGameState.players[opponentId];
          if (opponent && opponentStats) {
            statsContent.innerHTML += createPlayerStatBlock(
              opponentStats,
              opponent.name || "Adversaire",
              data.winner === opponentId
            );
          }

          // Afficher la raison de fin de partie
          reasonElement.textContent =
            "La partie s'est terminée car plus aucun joueur ne peut attaquer. ";
          if (data.winner === "tie") {
            reasonElement.textContent +=
              "Les deux joueurs ont le même nombre de personnages KO et de points de vie.";
          } else {
            const winnerStats = data.playerStats[data.winner];
            const loserId = Object.keys(data.playerStats).find(
              (id) => id !== data.winner
            );
            const loserStats = data.playerStats[loserId];

            if (
              winnerStats.koCharactersCount !== loserStats.koCharactersCount
            ) {
              reasonElement.textContent += `Le gagnant a été déterminé par le nombre de personnages KO (${winnerStats.koCharactersCount} contre ${loserStats.koCharactersCount}).`;
            } else {
              reasonElement.textContent += `Le gagnant a été déterminé par le total des points de vie restants (${winnerStats.totalHealth} contre ${loserStats.totalHealth}).`;
            }
          }

          // S'assurer que le bouton de retour au menu fonctionne correctement
          const quitGameBtn = document.getElementById("quitGameBtn");
          quitGameBtn.style.pointerEvents = "auto";
          quitGameBtn.style.opacity = "1";
          quitGameBtn.onclick = () => {
            // Informer le serveur que ce joueur quitte la partie
            if (socket) {
              socket.emit("leaveGame", {
                gameId: gameState.game.id,
                playerId: gameState.playerId,
              });
            }

            // Réinitialiser l'état local et retourner au menu
            gameState.game = null;
            gameState.playerId = null;
            currentGameId = null;
            currentPlayerId = null;

            // Recharger la page pour réinitialiser complètement l'état
            window.location.reload();
          };
        }

        // Ajouter un gestionnaire pour l'événement playerLeft
        socket.on("playerLeft", function (data) {
          if (data.playerId !== gameState.playerId) {
            showMessage(
              "L'autre joueur a quitté la partie. Vous pouvez également quitter."
            );
          }
        });

        // Ajouter cette fonction pour déboguer le contenu des cartes
        function debugCardProperties() {
          if (!gameState.game) return;

          const game = gameState.game;
          const player = game.players[gameState.playerId];

          if (player && player.cards) {
            console.log("Propriétés des cartes personnages:");
            if (
              player.cards.personnages &&
              player.cards.personnages.length > 0
            ) {
              console.table(player.cards.personnages[0]);
            }

            console.log("Propriétés des cartes bonus:");
            if (player.cards.bonus && player.cards.bonus.length > 0) {
              console.table(player.cards.bonus[0]);
            }
          }
        }

        // Ajouter cette fonction pour mieux visualiser les changements de tour
        function showTurnChange(isMyTurn) {
          // Créer un élément de notification de changement de tour
          const notification = document.createElement("div");
          notification.className = "turn-change-notification";
          notification.textContent = isMyTurn
            ? "À VOTRE TOUR"
            : "AU TOUR DE L'ADVERSAIRE";
          notification.style.position = "fixed";
          notification.style.top = "40%";
          notification.style.left = "50%";
          notification.style.transform = "translate(-50%, -50%)";
          notification.style.zIndex = "1000";
          notification.style.padding = "30px 50px";
          notification.style.backgroundColor = isMyTurn
            ? "rgba(76, 175, 80, 0.9)"
            : "rgba(255, 152, 0, 0.9)";
          notification.style.color = "white";
          notification.style.borderRadius = "8px";
          notification.style.fontWeight = "bold";
          notification.style.fontSize = "24px";
          notification.style.boxShadow = "0 4px 20px rgba(0, 0, 0, 0.4)";
          notification.style.transition = "opacity 0.5s";

          document.body.appendChild(notification);

          // Faire disparaître progressivement la notification
          setTimeout(() => {
            notification.style.opacity = "0";
          }, 1500);

          // Supprimer l'élément après l'animation
          setTimeout(() => {
            document.body.removeChild(notification);
          }, 2000);
        }

        // Ajouter une fonction pour vérifier si la partie est gagnée/perdue
        function checkGameOver() {
          if (!gameState.game) return false;

          const game = gameState.game;
          const player = game.players[gameState.playerId];

          // Trouver l'adversaire
          let opponent = null;
          for (const id in game.players) {
            if (id !== gameState.playerId) {
              opponent = game.players[id];
              break;
            }
          }

          if (!player || !opponent) return false;

          let gameEnded = false;
          let winner = null;
          let reason = "";
          let playersTotalHealth = {};

          // Fonction pour calculer les statistiques d'un joueur
          function calculatePlayerStats(playerState) {
            const stats = {
              totalHealth: 0,
              koCharactersCount: 0,
              canAttack: false,
            };

            Object.values(playerState.charactersState).forEach((char) => {
              stats.totalHealth += Math.max(
                0,
                char.currentHealth || char.pointsdevie || 0
              );
              if (char.currentHealth <= 0 || char.pointsdevie <= 0) {
                stats.koCharactersCount++;
              }
              if (
                (char.currentHealth > 0 || char.pointsdevie > 0) &&
                (char.currentTurns > 0 || char.tourattaque > 0)
              ) {
                stats.canAttack = true;
              }
            });

            return stats;
          }

          // Calculer les stats pour les deux joueurs
          const playerStats = calculatePlayerStats(player);
          const opponentStats = calculatePlayerStats(opponent);

          // Mettre à jour les points de vie totaux
          playersTotalHealth[gameState.playerId] = playerStats.totalHealth;
          playersTotalHealth[opponent.id] = opponentStats.totalHealth;

          // Vérifier si les deux joueurs ne peuvent plus attaquer
          if (!playerStats.canAttack && !opponentStats.canAttack) {
            gameEnded = true;
            reason = "no_more_attacks";

            // Comparer le nombre de personnages KO
            if (
              playerStats.koCharactersCount < opponentStats.koCharactersCount
            ) {
              winner = gameState.playerId;
            } else if (
              opponentStats.koCharactersCount < playerStats.koCharactersCount
            ) {
              winner = opponent.id;
            } else {
              // En cas d'égalité de personnages KO, comparer les points de vie totaux
              if (playerStats.totalHealth > opponentStats.totalHealth) {
                winner = gameState.playerId;
              } else if (opponentStats.totalHealth > playerStats.totalHealth) {
                winner = opponent.id;
              } else {
                winner = "tie"; // Match nul en cas d'égalité parfaite
              }
            }
          }

          if (gameEnded) {
            // Informer le serveur de la fin de partie
            socket.emit("gameEnded", {
              gameId: gameState.game.id,
              winner: winner,
              playersTotalHealth: playersTotalHealth,
              reason: reason,
              playerStats: {
                [gameState.playerId]: playerStats,
                [opponent.id]: opponentStats,
              },
            });

            // Afficher l'écran de fin de partie
            showGameOverScreen({
              winner: winner,
              playersTotalHealth: playersTotalHealth,
              newGameState: gameState.game,
              reason: reason,
              playerStats: {
                [gameState.playerId]: playerStats,
                [opponent.id]: opponentStats,
              },
            });

            return true;
          }

          return false;
        }

        // Fonction pour ajouter la possibilité de zoomer sur les cartes
        function setupCardZoom() {
          // Fonction pour zoomer une carte
          function zoomCard(card) {
            // Créer un overlay de fond
            const overlay = document.createElement("div");
            overlay.className = "overlay-background";
            document.body.appendChild(overlay);

            // Cloner la carte pour l'afficher en grand
            const zoomedCard = card.cloneNode(true);
            zoomedCard.classList.add("card-zoom");
            document.body.appendChild(zoomedCard);

            // Cliquer n'importe où pour fermer
            function closeZoom() {
              document.body.removeChild(overlay);
              document.body.removeChild(zoomedCard);
              document.removeEventListener("click", closeZoom);
            }

            document.addEventListener("click", closeZoom);
          }

          // Écouter les clics longs sur les cartes
          document.addEventListener("mousedown", function (e) {
            // Vérifier si c'est une carte
            let card = null;
            if (e.target.classList.contains("card")) {
              card = e.target;
            } else if (e.target.closest(".card")) {
              card = e.target.closest(".card");
            }

            if (card) {
              const timer = setTimeout(() => {
                zoomCard(card);
              }, 500); // Zoom après 500ms

              // Annuler le zoom si le clic est relâché avant
              const clearTimer = () => {
                clearTimeout(timer);
                document.removeEventListener("mouseup", clearTimer);
              };

              document.addEventListener("mouseup", clearTimer);
            }
          });
        }

        // Appeler cette fonction après le chargement du DOM
        setupCardZoom();

        function displayMessage(message, type = "info") {
          const messageContainer = document.getElementById("messages");
          const messageElement = document.createElement("div");
          messageElement.className = `message message-${type}`;
          messageElement.textContent = message;
          messageContainer.appendChild(messageElement);

          // Auto-remove after 5 seconds
          setTimeout(() => {
            messageElement.remove();
          }, 5000);
        }

        // Modifier la gestion de l'événement gameOver
        socket.on("gameOver", function (data) {
          if (!data || !data.newGameState) return;

          const game = data.newGameState;
          const winner = game.players[data.winner];

          if (!winner) return;

          // Calculer les points de vie totaux pour chaque joueur
          const calculatePlayerHealth = (player) => {
            if (!player || !player.charactersState) return 0;
            return Object.values(player.charactersState).reduce(
              (total, char) => {
                return total + (parseInt(char.pointsdevie) || 0);
              },
              0
            );
          };

          // Mettre à jour les statistiques
          const stats = {
            [game.players.player1?.id]: calculatePlayerHealth(
              game.players.player1
            ),
            [game.players.player2?.id]: calculatePlayerHealth(
              game.players.player2
            ),
          };

          // Afficher l'écran de fin de partie avec les statistiques correctes
          showGameOverScreen({
            winner: data.winner,
            playersTotalHealth: stats,
            newGameState: game,
          });
        });

        function updateGameStats(playersTotalHealth, game) {
          const stats = document.querySelector(".stats-container");
          if (!stats || !game || !game.players) return;

          stats.innerHTML = "";

          Object.entries(game.players).forEach(([playerId, player]) => {
            const totalHealth = playersTotalHealth[playerId] || 0;
            const statElement = document.createElement("div");
            statElement.className = "player-stat";
            statElement.innerHTML = `
              <span>${player.name}</span>
              <span>${totalHealth} PV restants</span>
            `;
            if (playerId === game.winner) {
              statElement.innerHTML += " 🏆";
            }
            stats.appendChild(statElement);
          });
        }

        let currentPlayerId = null;
        let currentGameId = null;

        function updateGameState(newState) {
          if (!newState) return;

          if (newState.playerId) {
            currentPlayerId = newState.playerId;
          }
          if (newState.game) {
            gameState.game = newState.game;
            currentGameId = newState.game.id;
            renderGameState();
          }
        }

        function renderGameState() {
          if (!gameState.game) return;
          renderCards();
          updateTurnInfo();
          updatePlayerNames();
        }

        function updateTurnInfo() {
          const turnInfo = document.getElementById("turnInfo");
          const turnNumber = document.getElementById("turnNumber");
          if (turnInfo && gameState.game) {
            turnInfo.textContent =
              gameState.game.currentTurn === currentPlayerId
                ? "C'est votre tour!"
                : "Au tour de l'adversaire";
          }
          if (turnNumber) {
            turnNumber.textContent = `Tour ${gameState.currentTurnNumber || 1}`;
          }
        }

        function updatePlayerNames() {
          const player1Name = document.getElementById("player1Name");
          const player2Name = document.getElementById("player2Name");

          if (gameState.game && gameState.game.players) {
            const currentPlayer = gameState.game.players[currentPlayerId];
            const opponent = Object.values(gameState.game.players).find(
              (p) => p.id !== currentPlayerId
            );

            if (currentPlayer && player1Name) {
              player1Name.textContent = `Joueur 1: ${currentPlayer.name}`;
            }
            if (opponent && player2Name) {
              player2Name.textContent = `Joueur 2: ${opponent.name}`;
            }
          }
        }

        function hideAllScreens() {
          // Cacher tous les écrans du jeu
          Object.keys(screens).forEach((key) => {
            screens[key].classList.add("hidden");
          });
          // Cacher aussi l'écran de fin de partie
          const gameOverScreen = document.getElementById("gameOverScreen");
          if (gameOverScreen) {
            gameOverScreen.classList.add("hidden");
          }
        }

        socket.on("attackPerformed", (data) => {
          if (!gameState.game) return;

          // Si le serveur nous a envoyé un nouvel état du jeu, l'utiliser
          if (data.newGameState) {
            gameState.game = data.newGameState;
          } else {
            // Sinon, simuler l'attaque côté client
            const { attackerId, targetId, damage } = data;

            // Trouver le joueur attaquant et le joueur cible
            let attacker = null;
            let target = null;
            for (const playerId in gameState.game.players) {
              const player = gameState.game.players[playerId];
              if (player.charactersState[attackerId]) {
                attacker = player;
              }
              if (player.charactersState[targetId]) {
                target = player;
              }
            }

            if (attacker && target) {
              // Appliquer les dégâts
              const targetState = target.charactersState[targetId];
              targetState.currentHealth = Math.max(
                0,
                targetState.currentHealth - damage
              );

              // Décrémenter le nombre de tours d'attaque
              const attackerState = attacker.charactersState[attackerId];
              attackerState.currentTurns = Math.max(
                0,
                attackerState.currentTurns - 1
              );

              // Mettre à jour les bonus actifs
              if (attackerState.activeBonus) {
                attackerState.activeBonus = attackerState.activeBonus.filter(
                  (bonus) => {
                    bonus.remainingTurns--;
                    return bonus.remainingTurns > 0;
                  }
                );

                // Recalculer l'attaque en tenant compte des bonus restants
                const baseAttack =
                  attackerState.baseAttack || attackerState.currentAttack;
                let totalBonus = 1;
                attackerState.activeBonus.forEach((bonus) => {
                  totalBonus += bonus.percentage / 100;
                });
                attackerState.currentAttack = Math.floor(
                  baseAttack * totalBonus
                );
              }
            }
          }

          // Afficher un message avec les noms des personnages
          const attackerName =
            data.attackerName ||
            Object.values(gameState.game.players)
              .find((p) => p.charactersState[data.attackerId])
              ?.cards.personnages.find((c) => c.id === data.attackerId)
              ?.nomcarteperso ||
            "un personnage";

          const targetName = // Correction ici : ajout de "const targetName ="
            data.targetName ||
            Object.values(gameState.game.players)
              .find((p) => p.charactersState[data.targetId])
              ?.cards.personnages.find((c) => c.id === data.targetId)
              ?.nomcarteperso ||
            "un personnage";

          showMessage(
            `${attackerName} attaque ${targetName} et inflige ${data.damage} points de dégâts`
          );

          // Mettre à jour l'affichage
          renderCards();
        });

        document
          .getElementById("cancelGameBtn")
          .addEventListener("click", () => {
            if (currentGameId) {
              socket.emit("cancelGame", { gameId: currentGameId });
            }
            cleanupMessages();
            showScreen("homeScreen");
          });

        document
          .getElementById("cancelWaitingBtn")
          .addEventListener("click", () => {
            if (currentGameId) {
              socket.emit("leaveGame", { gameId: currentGameId });
            }
            cleanupMessages();
            showScreen("homeScreen");
          });

        function cleanupMessages() {
          const messages = document.querySelectorAll(
            'div[style*="position: fixed"]'
          );
          messages.forEach((msg) => {
            if (document.body.contains(msg)) {
              document.body.removeChild(msg);
            }
          });
        }

        socket.on("gameError", (data) => {
          showMessage(data.message, true);
          cleanupMessages();
          showScreen("homeScreen");
        });

        function showGameOverScreen() {
          if (!gameState.game) return;

          // Cacher tous les écrans sauf l'écran de fin de partie
          document.querySelectorAll(".screen").forEach((screen) => {
            screen.classList.add("hidden");
          });
          gameOverScreen.classList.remove("hidden");

          // Déterminer le résultat pour le joueur actuel
          const isWinner = gameState.game.winner === gameState.playerId;
          const result = {
            title: isWinner ? "Victoire !" : "Défaite",
            message: isWinner
              ? "Félicitations, vous avez gagné la partie !"
              : "Dommage, vous avez perdu la partie.",
          };

          // Mettre à jour le titre et le message
          document.getElementById("gameOverTitle").textContent = result.title;
          document.getElementById("gameOverMessage").textContent =
            result.message;

          // Créer une fonction pour afficher les statistiques d'un joueur
          function createPlayerStatBlock(player, isCurrentPlayer) {
            const playerStats = document.createElement("div");
            playerStats.className = `player-stats ${
              isCurrentPlayer ? "current-player" : "opponent"
            }`;
            playerStats.innerHTML = `
              <h3>${
                isCurrentPlayer
                  ? "Vos statistiques"
                  : "Statistiques de l'adversaire"
              }</h3>
              <div class="stats-grid">
                ${Object.entries(player.charactersState)
                  .map(([charId, charState]) => {
                    const card = player.cards.personnages.find(
                      (c) => c.id === charId
                    );
                    if (!card) return "";

                    const healthClass =
                      charState.pointsdevie <= 0
                        ? "ko"
                        : charState.pointsdevie <= 30
                        ? "critical"
                        : charState.pointsdevie <= 50
                        ? "warning"
                        : "good";

                    return `
                        <div class="character-stat">
                          <div class="character-name">${
                            card.nomcarteperso
                          }</div>
                          <div class="stat-item">
                            <span class="health-${healthClass}">${
                      charState.pointsdevie <= 0 ? "KO" : charState.pointsdevie
                    }</span>
                          </div>
                          <div class="stat-item">${charState.forceattaque}</div>
                          <div class="stat-item">${charState.tourattaque}</div>
                        </div>
                      `;
                  })
                  .join("")}
              </div>
            `;
            return playerStats;
          }

          // Afficher les statistiques des deux joueurs
          const playerStatsContent =
            document.getElementById("playerStatsContent");
          playerStatsContent.innerHTML = "";

          // Trouver le joueur actuel et l'adversaire
          let currentPlayer = null;
          let opponent = null;
          for (const playerId in gameState.game.players) {
            if (playerId === gameState.playerId) {
              currentPlayer = gameState.game.players[playerId];
            } else {
              opponent = gameState.game.players[playerId];
            }
          }

          if (currentPlayer && opponent) {
            playerStatsContent.appendChild(
              createPlayerStatBlock(currentPlayer, true)
            );
            playerStatsContent.appendChild(
              createPlayerStatBlock(opponent, false)
            );
          }

          // Afficher la raison de la fin de partie
          const endReason = document.getElementById("endReason");
          if (gameState.game.endReason === "all_characters_ko") {
            endReason.textContent =
              "Tous les personnages d'un joueur ont été mis KO";
          } else if (gameState.game.endReason === "player_left") {
            endReason.textContent = "Un joueur a quitté la partie";
          } else if (gameState.game.endReason === "player_abandoned") {
            endReason.textContent = "Un joueur a abandonné la partie";
          }

          // Gérer le bouton retour au menu
          const quitButton = document.getElementById("quitGame");
          quitButton.onclick = () => {
            // Réinitialiser l'état du jeu
            gameState = {
              playerId: null,
              game: null,
              isMyTurn: false,
              selectedCharacter: null,
              selectedBonus: null,
              targetCharacter: null,
              currentTurnNumber: 1,
            };

            // Retourner au menu principal
            showScreen("menu");
          };
        }

        socket.on("gameOver", (data) => {
          console.log("Fin de partie:", data);
          if (gameState.game) {
            gameState.game.winner = data.winner;
            gameState.game.endReason = data.reason;
            showGameOverScreen();
          }
        });

        socket.on("gameStateUpdate", (data) => {
          console.log("Mise à jour de l'état du jeu:", data);
          if (data.game) {
            gameState.game = data.game;
            if (data.game.winner) {
              showGameOverScreen();
            } else {
              renderGame();
            }
          }
        });
      });
    </script>
  </body>
</html>
