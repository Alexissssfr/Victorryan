<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Victorryan</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        margin-top: 20px;
      }
      .hidden {
        display: none;
      }
      button {
        padding: 8px 16px;
        background-color: #4caf50;
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 4px;
        margin: 5px;
      }
      button:hover {
        background-color: #45a049;
      }
      input {
        padding: 8px;
        margin-bottom: 10px;
        width: 100%;
        border-radius: 4px;
        border: 1px solid #ddd;
      }
      .game-id {
        background-color: #f1f1f1;
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      /* Styles pour les cartes */
      .cards-container {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-top: 10px;
        justify-content: flex-start;
      }

      .card {
        width: 180px;
        height: 300px;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 10px;
        background-color: white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        margin-bottom: 15px;
      }

      .card:hover {
        transform: translateY(-5px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .card.selected {
        transform: translateY(-10px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        border-width: 3px;
      }

      .card-image {
        width: 100%;
        height: 180px;
        background-size: contain;
        background-position: center;
        background-repeat: no-repeat;
        margin-bottom: 5px;
      }

      .card-overlay {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 8px;
        border-top: 1px solid #ddd;
      }

      .card-title {
        font-weight: bold;
        text-align: center;
        margin-bottom: 5px;
        font-size: 14px;
      }

      .card-stats {
        font-size: 12px;
        line-height: 1.4;
      }

      .personnage-card {
        background-color: #e8f5e9;
      }

      .bonus-card {
        background-color: #e3f2fd;
      }

      .opponent-card {
        background-color: #fff3e0;
      }

      .player-section {
        background-color: white;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .game-status {
        background-color: #333;
        color: white;
        padding: 10px;
        text-align: center;
        border-radius: 4px;
        margin-bottom: 20px;
      }

      .actions {
        display: flex;
        justify-content: center;
        margin-top: 20px;
      }

      .active-bonus-indicator {
        position: absolute;
        top: 5px;
        right: 5px;
        background-color: #ff9800;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
      }

      .game-info {
        background-color: #f1f1f1;
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
      }

      .turn-indicator {
        font-weight: bold;
        color: #4caf50;
      }

      /* Ajouter une classe pour agrandir la carte au survol */
      .card-zoom {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(2);
        z-index: 1000;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
      }

      /* Ajoutez un fond semi-transparent quand une carte est zoomée */
      .overlay-background {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 999;
      }

      .card.depleted {
        opacity: 0.7;
        background-color: #f0f0f0;
      }

      .card.cannot-attack {
        opacity: 0.6;
        background-color: #ffebee;
        border: 1px solid #ffcdd2;
        cursor: not-allowed;
      }

      .card.can-attack {
        border: 2px solid #4caf50;
        box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
      }

      .card.can-target {
        border: 2px solid #f44336;
        box-shadow: 0 0 5px rgba(244, 67, 54, 0.5);
      }

      .turn-info {
        background-color: #333;
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 14px;
        margin-bottom: 5px;
      }

      .attack-status {
        background-color: #ff9800;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        display: inline-block;
        margin-left: 10px;
      }

      .turn-change-notification {
        position: fixed;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        padding: 30px 50px;
        background-color: rgba(76, 175, 80, 0.9);
        color: white;
        border-radius: 8px;
        font-weight: bold;
        font-size: 24px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        transition: opacity 0.5s;
      }
    </style>
  </head>
  <body>
    <h1>Victorryan - Jeu de cartes</h1>

    <!-- Écran initial -->
    <div id="homeScreen">
      <button id="createGameBtn">Créer une partie</button>
      <hr />
      <div>
        <h3>Rejoindre une partie</h3>
        <input type="text" id="playerNameInput" placeholder="Votre nom" />
        <input type="text" id="gameIdInput" placeholder="ID de la partie" />
        <button id="joinGameBtn">Rejoindre</button>
      </div>
    </div>

    <!-- Écran de création de partie -->
    <div id="createdGameScreen" class="hidden">
      <h2>Partie créée!</h2>
      <p>Partagez cet ID avec votre adversaire:</p>
      <div class="game-id">
        <span id="gameIdDisplay"></span>
        <button id="copyGameIdBtn">Copier</button>
      </div>
      <div>
        <input type="text" id="creatorNameInput" placeholder="Votre nom" />
        <button id="joinAsCreatorBtn">Rejoindre en tant que créateur</button>
      </div>
    </div>

    <!-- Écran d'attente -->
    <div id="waitingScreen" class="hidden">
      <h2>En attente...</h2>
      <p id="waitingMessage">En attente d'un adversaire</p>
    </div>

    <!-- Écran de jeu -->
    <div id="gameScreen" class="hidden">
      <div class="game-status" id="gameStatus">En attente...</div>

      <div class="game-info">
        <h3>Informations de la partie</h3>
        <div id="gameInfo">
          <p>
            Votre tour:
            <span id="turnIndicator" class="turn-indicator">En attente...</span>
          </p>
          <p>Joueur 1: <span id="player1Name"></span></p>
          <p>Joueur 2: <span id="player2Name"></span></p>
        </div>
      </div>

      <div class="player-section">
        <h3>Vos personnages</h3>
        <div class="cards-container" id="yourCharacters"></div>
      </div>

      <div class="player-section">
        <h3>Vos bonus</h3>
        <div class="cards-container" id="yourBonus"></div>
      </div>

      <div class="player-section">
        <h3>Personnages adverses</h3>
        <div class="cards-container" id="opponentCharacters"></div>
      </div>

      <div class="actions">
        <button id="attackBtn" class="hidden">Attaquer</button>
        <button id="playBonusBtn" class="hidden">Jouer bonus</button>
        <button id="endTurnBtn" class="hidden">Terminer le tour</button>
      </div>
    </div>

    <div id="messages"></div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // DOM Elements
        const screens = {
          home: document.getElementById("homeScreen"),
          created: document.getElementById("createdGameScreen"),
          waiting: document.getElementById("waitingScreen"),
          game: document.getElementById("gameScreen"),
        };

        const createGameBtn = document.getElementById("createGameBtn");
        const joinGameBtn = document.getElementById("joinGameBtn");
        const joinAsCreatorBtn = document.getElementById("joinAsCreatorBtn");
        const gameIdDisplay = document.getElementById("gameIdDisplay");
        const copyGameIdBtn = document.getElementById("copyGameIdBtn");
        const gameStatus = document.getElementById("gameStatus");
        const endTurnBtn = document.getElementById("endTurnBtn");
        const attackBtn = document.getElementById("attackBtn");
        const playBonusBtn = document.getElementById("playBonusBtn");
        const messages = document.getElementById("messages");

        // DOM Elements pour les cartes
        const yourCharacters = document.getElementById("yourCharacters");
        const yourBonus = document.getElementById("yourBonus");
        const opponentCharacters =
          document.getElementById("opponentCharacters");

        // Game State
        let gameState = {
          gameId: null,
          playerId: null,
          playerName: null,
          isMyTurn: false,
          gameData: null,
          selectedCharacter: null,
          selectedBonus: null,
          targetCharacter: null,
        };

        // Socket.io
        const socket = io();

        // Functions
        function showScreen(screenName) {
          Object.keys(screens).forEach((key) => {
            screens[key].classList.add("hidden");
          });
          screens[screenName].classList.remove("hidden");
        }

        function showMessage(text, isError = false) {
          const p = document.createElement("p");
          p.textContent = text;
          if (isError) p.style.color = "red";
          messages.appendChild(p);
          messages.scrollTop = messages.scrollHeight;
        }

        // Fonction pour afficher les cartes des joueurs
        function renderCards() {
          if (!gameState.gameData) return;

          const game = gameState.gameData;
          const player = game.players[gameState.playerId];

          if (!player || !player.cards) {
            console.log("Données du joueur non disponibles");
            return;
          }

          // Si nous sommes en train d'attendre que l'attaque soit traitée, désactiver toutes les interactions
          const attackInProgress = gameState.isMyTurn && game.attackPerformed;

          // Trouver l'adversaire
          let opponent = null;
          for (const id in game.players) {
            if (id !== gameState.playerId) {
              opponent = game.players[id];
              break;
            }
          }

          // Afficher vos cartes personnages
          yourCharacters.innerHTML = "";
          if (player.cards.personnages) {
            player.cards.personnages.forEach((card) => {
              const characterState = player.charactersState[card.id];
              const cardEl = createCharacterCard(card, characterState, false);

              // Simplification de la condition pour ajouter l'événement de clic
              // C'est mon tour ET le personnage est vivant ET il a des tours d'attaque ET je n'ai pas encore attaqué
              const canAttack =
                gameState.isMyTurn &&
                characterState &&
                characterState.currentHealth > 0 &&
                characterState.currentTurns > 0 &&
                !game.attackPerformed;

              if (canAttack) {
                cardEl.addEventListener("click", () =>
                  selectYourCharacter(card.id)
                );
                cardEl.classList.add("can-attack");
              } else if (
                characterState &&
                (characterState.currentHealth <= 0 ||
                  characterState.currentTurns <= 0)
              ) {
                cardEl.classList.add("cannot-attack");
              }

              if (card.id === gameState.selectedCharacter) {
                cardEl.classList.add("selected");
              }

              yourCharacters.appendChild(cardEl);
            });
          }

          // Afficher vos cartes bonus
          yourBonus.innerHTML = "";
          player.cards.bonus.forEach((card) => {
            const cardEl = createBonusCard(card);

            // N'ajouter l'événement de clic que si le bonus a encore des tours
            const bonusTours = parseInt(card.tourbonus) || 0;
            if (gameState.isMyTurn && bonusTours > 0) {
              cardEl.addEventListener("click", () => selectBonus(card.id));
              cardEl.classList.add("can-play");
            } else if (bonusTours <= 0) {
              cardEl.classList.add("depleted");
            }

            if (card.id === gameState.selectedBonus) {
              cardEl.classList.add("selected");
            }

            yourBonus.appendChild(cardEl);
          });

          // Afficher les cartes personnages de l'adversaire
          opponentCharacters.innerHTML = "";
          if (opponent && opponent.cards) {
            opponent.cards.personnages.forEach((card) => {
              const characterState = opponent.charactersState[card.id];
              const cardEl = createCharacterCard(card, characterState, true);

              // N'ajouter l'événement de clic que si le personnage est vivant
              if (
                gameState.isMyTurn &&
                gameState.selectedCharacter &&
                characterState &&
                characterState.currentHealth > 0
              ) {
                cardEl.addEventListener("click", () =>
                  selectOpponentCharacter(card.id)
                );
                cardEl.classList.add("can-target");
              }

              if (card.id === gameState.targetCharacter) {
                cardEl.classList.add("selected");
              }

              opponentCharacters.appendChild(cardEl);
            });
          }

          // Mettre à jour les boutons d'action
          updateActionButtons();

          // Si une attaque est en cours de traitement, ajouter une indication visuelle
          if (attackInProgress) {
            const message = document.createElement("div");
            message.className = "turn-info";
            message.textContent = "Changement de tour en cours...";
            message.style.position = "fixed";
            message.style.top = "50%";
            message.style.left = "50%";
            message.style.transform = "translate(-50%, -50%)";
            message.style.zIndex = "1000";
            message.style.padding = "20px";
            message.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
            message.style.color = "white";
            message.style.borderRadius = "8px";

            // Supprimer les anciennes notifications si elles existent
            const existingMessages = document.querySelectorAll(".turn-info");
            existingMessages.forEach((m) => m.remove());

            document.body.appendChild(message);

            // Supprimer après un court délai
            setTimeout(() => {
              message.remove();
            }, 2000);
          }
        }

        function createCharacterCard(card, state, isOpponent) {
          const cardEl = document.createElement("div");
          cardEl.className = `card ${
            isOpponent ? "opponent-card" : "personnage-card"
          }`;
          cardEl.dataset.id = card.id;

          // Récupérer les valeurs correctes, avec état actuel ou valeurs de base
          // Utiliser les noms de propriétés corrects des données reçues
          const health =
            state && state.currentHealth !== undefined
              ? state.currentHealth
              : card.pointsdevie
              ? parseInt(card.pointsdevie)
              : 100;

          const attack =
            state && state.currentAttack !== undefined
              ? state.currentAttack
              : card.forceattaque
              ? parseInt(card.forceattaque)
              : 30;

          const turns =
            state && state.currentTurns !== undefined
              ? state.currentTurns
              : card.tourattaque
              ? parseInt(card.tourattaque)
              : 2;

          // Vérifier si des bonus sont actifs
          const activeBonus =
            state && state.activeBonus ? state.activeBonus : [];

          // Créer l'élément d'image
          let imageHtml = "";
          if (card.fond) {
            imageHtml = `<div class="card-image" style="background-image: url('${card.fond}')"></div>`;
          }

          // Indicateur de bonus actifs
          const bonusIndicator =
            activeBonus.length > 0
              ? `<div class="active-bonus-indicator">${activeBonus.length}</div>`
              : "";

          // Créer une description plus détaillée des bonus actifs
          let activeBonusHtml = "";
          if (activeBonus.length > 0) {
            activeBonusHtml = `
              <div style="font-size: 10px; color: #ff9800; margin-top: 3px;">
                <strong>Bonus actifs:</strong> ${activeBonus
                  .map((b) => b.bonusId)
                  .join(", ")}
              </div>
            `;
          }

          // Utiliser le nom correct de la carte
          const cardName = card.nomcarteperso || card.id || "Personnage";
          const cardPower = card.nomdupouvoir || "";
          const cardDescription = card.description || "";

          // Construire le HTML de la carte
          cardEl.innerHTML = `
            ${bonusIndicator}
            <div class="card-title">${cardName}</div>
            ${imageHtml}
            <div class="card-overlay">
              <div class="card-stats">
                <div><strong>PV:</strong> ${health}</div>
                <div><strong>Attaque:</strong> ${attack}</div>
                <div><strong>Tours d'attaque:</strong> ${turns}</div>
                ${activeBonusHtml}
                <div style="font-size: 10px; color: #666; margin-top: 3px;">
                  <strong>${cardPower}</strong>
                  <div>${cardDescription}</div>
                </div>
              </div>
            </div>
          `;

          return cardEl;
        }

        function createBonusCard(card) {
          const cardEl = document.createElement("div");
          cardEl.className = "card bonus-card";
          cardEl.dataset.id = card.id;

          // Ajouter la classe 'depleted' si le bonus n'a plus de tours
          if (parseInt(card.tourbonus) <= 0 || card.disabled) {
            cardEl.classList.add("depleted");
          }

          // Créer l'élément d'image
          let imageHtml = "";
          if (card.fond) {
            imageHtml = `<div class="card-image" style="background-image: url('${card.fond}')"></div>`;
          }

          // Récupérer les valeurs correctes
          const pourcentage = card.pourcentagebonus
            ? parseInt(card.pourcentagebonus)
            : 0;
          const tours = card.tourbonus ? parseInt(card.tourbonus) : 0;
          const effet = card.description || "-";
          const nom = card.nomcartebonus || card.id || "Bonus";
          const pouvoir = card.nomdupouvoir || "";

          // Mettre en évidence les tours restants
          const toursHtml =
            tours <= 0
              ? `<div><strong>Tours:</strong> <span style="color:red">0</span></div>`
              : `<div><strong>Tours:</strong> ${tours}</div>`;

          // Construire le HTML de la carte
          cardEl.innerHTML = `
            <div class="card-title">${nom}</div>
            ${imageHtml}
            <div class="card-overlay">
              <div class="card-stats">
                <div><strong>Pouvoir:</strong> ${pouvoir}</div>
                <div><strong>Pourcentage:</strong> ${pourcentage}%</div>
                ${toursHtml}
                <div style="font-size: 10px; color: #666; margin-top: 3px;">${effet}</div>
              </div>
            </div>
          `;

          return cardEl;
        }

        function selectYourCharacter(cardId) {
          if (!gameState.isMyTurn) return;

          if (gameState.selectedCharacter === cardId) {
            gameState.selectedCharacter = null;
          } else {
            gameState.selectedCharacter = cardId;
          }

          updateActionButtons();
          renderCards();
        }

        function selectOpponentCharacter(cardId) {
          if (!gameState.isMyTurn || !gameState.selectedCharacter) return;

          if (gameState.targetCharacter === cardId) {
            gameState.targetCharacter = null;
          } else {
            gameState.targetCharacter = cardId;

            // Si on a sélectionné un personnage à attaquer, on peut proposer d'attaquer
            if (gameState.selectedCharacter && gameState.targetCharacter) {
              attackBtn.classList.remove("hidden");
            }
          }

          renderCards();
        }

        function selectBonus(cardId) {
          if (!gameState.isMyTurn) return;

          // Vérifier si le bonus est déjà sélectionné
          if (gameState.selectedBonus === cardId) {
            gameState.selectedBonus = null;
          } else {
            gameState.selectedBonus = cardId;
          }

          updateActionButtons();
          renderCards();
        }

        function updateActionButtons() {
          if (gameState.isMyTurn) {
            endTurnBtn.classList.remove("hidden");

            // Le bouton d'attaque est visible seulement si un personnage est sélectionné et une cible
            attackBtn.classList.toggle(
              "hidden",
              !(gameState.selectedCharacter && gameState.targetCharacter)
            );

            // Le bouton pour jouer un bonus est visible seulement si un bonus et un personnage sont sélectionnés
            playBonusBtn.classList.toggle(
              "hidden",
              !(gameState.selectedBonus && gameState.selectedCharacter)
            );
          } else {
            endTurnBtn.classList.add("hidden");
            attackBtn.classList.add("hidden");
            playBonusBtn.classList.add("hidden");
          }
        }

        function updateGameStatus() {
          let statusText = "";

          if (gameState.gameData && gameState.gameData.status === "playing") {
            statusText = gameState.isMyTurn
              ? "C'est votre tour!"
              : "Au tour de l'adversaire";

            // Ajouter l'information sur l'attaque
            if (gameState.isMyTurn) {
              const attackStatus =
                gameState.gameData && gameState.gameData.attackPerformed
                  ? '<span class="attack-status">Attaque effectuée</span>'
                  : '<span class="attack-status">Attaque disponible</span>';

              statusText += " " + attackStatus;
            }
          } else if (
            gameState.gameData &&
            gameState.gameData.status === "finished"
          ) {
            if (gameState.gameData.winner === gameState.playerId) {
              statusText = "Victoire! La partie est terminée.";
            } else if (gameState.gameData.winner === "tie") {
              statusText = "Match nul! La partie est terminée.";
            } else {
              statusText = "Défaite! La partie est terminée.";
            }
          } else {
            statusText = "En attente d'un adversaire...";
          }

          gameStatus.innerHTML = statusText;
        }

        // Event handlers
        createGameBtn.addEventListener("click", () => {
          fetch("/api/games", {
            method: "POST",
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.success) {
                gameState.gameId = data.gameId;
                gameIdDisplay.textContent = data.gameId;
                showScreen("created");
              } else {
                showMessage("Erreur: " + data.error, true);
              }
            })
            .catch((error) => {
              showMessage("Erreur de connexion", true);
              console.error("Error:", error);
            });
        });

        joinGameBtn.addEventListener("click", () => {
          const name = document.getElementById("playerNameInput").value.trim();
          const gameId = document.getElementById("gameIdInput").value.trim();

          if (!name || !gameId) {
            showMessage("Nom et ID de partie requis", true);
            return;
          }

          joinGame(gameId, name);
        });

        joinAsCreatorBtn.addEventListener("click", () => {
          const name = document.getElementById("creatorNameInput").value.trim();

          if (!name) {
            showMessage("Nom requis", true);
            return;
          }

          joinGame(gameState.gameId, name);
        });

        copyGameIdBtn.addEventListener("click", () => {
          navigator.clipboard
            .writeText(gameState.gameId)
            .then(() => showMessage("ID copié!"))
            .catch(() => showMessage("Erreur de copie", true));
        });

        endTurnBtn.addEventListener("click", () => {
          if (!gameState.isMyTurn) return;

          socket.emit("endTurn", {
            gameId: gameState.gameId,
            playerId: gameState.playerId,
          });

          // Réinitialiser les sélections
          gameState.selectedCharacter = null;
          gameState.selectedBonus = null;
          gameState.targetCharacter = null;
        });

        attackBtn.addEventListener("click", () => {
          if (
            !gameState.isMyTurn ||
            !gameState.selectedCharacter ||
            !gameState.targetCharacter
          )
            return;

          // La vérification d'attaque est maintenant inutile car le tour changera automatiquement
          // après une attaque, mais nous la gardons pour la sécurité (en cas de problème réseau)
          if (gameState.gameData.attackPerformed) {
            showMessage(
              "Vous avez déjà attaqué ce tour. C'est au tour de l'adversaire.",
              true
            );

            // NOUVEAU CODE : Ne pas permettre d'attaquer à nouveau
            return;
          }

          // Vérification que le personnage a des tours d'attaque et est en vie
          const game = gameState.gameData;
          const player = game.players[gameState.playerId];
          const attacker = player.charactersState[gameState.selectedCharacter];

          if (attacker.currentHealth <= 0) {
            showMessage(
              "Ce personnage est vaincu et ne peut pas attaquer.",
              true
            );
            return;
          }

          if (attacker.currentTurns <= 0) {
            showMessage(
              "Ce personnage n'a plus de tours d'attaque disponibles.",
              true
            );
            return;
          }

          // Trouver les noms des cartes pour l'affichage
          const attackerCard = player.cards.personnages.find(
            (c) => c.id === gameState.selectedCharacter
          );
          const attackerName = attackerCard
            ? attackerCard.nomcarteperso
            : gameState.selectedCharacter;

          // Trouver l'adversaire et la carte cible
          let opponent = null;
          for (const id in game.players) {
            if (id !== gameState.playerId) {
              opponent = game.players[id];
              break;
            }
          }

          let targetName = gameState.targetCharacter;
          if (opponent) {
            const targetCard = opponent.cards.personnages.find(
              (c) => c.id === gameState.targetCharacter
            );
            if (targetCard) {
              targetName = targetCard.nomcarteperso;
            }
          }

          socket.emit("attackCharacter", {
            gameId: gameState.gameId,
            playerId: gameState.playerId,
            attackerId: gameState.selectedCharacter,
            targetId: gameState.targetCharacter,
          });

          // Modification ici aussi: informer que le tour passe automatiquement
          showMessage(
            `${attackerName} attaque ${targetName}. Le tour passe à l'adversaire.`
          );

          // Mettre à jour l'affichage
          updateActionButtons();
          renderCards();
        });

        playBonusBtn.addEventListener("click", () => {
          if (
            !gameState.isMyTurn ||
            !gameState.selectedBonus ||
            !gameState.selectedCharacter
          )
            return;

          socket.emit("playBonus", {
            gameId: gameState.gameId,
            playerId: gameState.playerId,
            bonusId: gameState.selectedBonus,
            targetCharacterId: gameState.selectedCharacter,
          });

          showMessage(
            `Bonus ${gameState.selectedBonus} joué sur ${gameState.selectedCharacter}`
          );

          // Réinitialiser seulement la sélection de bonus, pas le personnage
          // pour permettre d'appliquer plusieurs bonus sur le même personnage
          gameState.selectedBonus = null;
          renderCards();
        });

        // Game functions
        function joinGame(gameId, playerName) {
          showScreen("waiting");
          document.getElementById("waitingMessage").textContent =
            "Connexion en cours...";

          fetch(`/api/games/${gameId}/join`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name: playerName }),
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.success) {
                gameState.gameId = data.gameId;
                gameState.playerId = data.playerId;
                gameState.playerName = playerName;

                // Sauvegarder dans localStorage
                localStorage.setItem("gameId", data.gameId);
                localStorage.setItem("playerId", data.playerId);
                localStorage.setItem("playerName", playerName);

                // Connexion socket
                document.getElementById("waitingMessage").textContent =
                  "En attente d'un adversaire...";
                socket.emit("joinRoom", {
                  gameId: data.gameId,
                  playerId: data.playerId,
                });
              } else {
                showMessage("Erreur: " + data.error, true);
                showScreen("home");
              }
            })
            .catch((error) => {
              showMessage("Erreur de connexion", true);
              showScreen("home");
              console.error("Error:", error);
            });
        }

        // Socket.io Events
        socket.on("connect", () => {
          console.log("Connecté au serveur");
        });

        socket.on("error", (data) => {
          showMessage("Erreur: " + data.message, true);
        });

        socket.on("gameState", (data) => {
          console.log("État du jeu reçu:", data);

          gameState.gameData = data.game;
          gameState.isMyTurn =
            gameState.gameData.currentTurn === gameState.playerId;

          if (gameState.gameData.status === "playing") {
            showScreen("game");
            updateGameStatus();
            renderCards();
            debugCardProperties();
          }
        });

        socket.on("playerJoined", (data) => {
          showMessage(`${data.playerName} a rejoint la partie`);
        });

        socket.on("gameReady", (data) => {
          console.log("Partie prête:", data);
          gameState.gameData = data.game;
          gameState.isMyTurn = data.startingPlayer === gameState.playerId;

          showScreen("game");
          updateGameStatus();
          renderCards();

          showMessage("La partie commence!");
        });

        socket.on("turnChanged", (data) => {
          gameState.isMyTurn = data.currentTurn === gameState.playerId;
          showTurnChange(gameState.isMyTurn);

          // Si c'est notre tour, réinitialiser l'attaque
          if (gameState.isMyTurn && data.newGameState) {
            // Mettre à jour l'état du jeu avec les nouvelles données
            gameState.gameData = data.newGameState;
            // Réinitialiser le flag d'attaque pour le nouveau tour
            if (gameState.gameData) {
              gameState.gameData.attackPerformed = false;
            }
          }

          updateGameStatus();
          updateActionButtons();

          if (gameState.isMyTurn) {
            showMessage("C'est votre tour!");
          } else {
            showMessage("Au tour de l'adversaire");
          }

          // Mettre à jour l'affichage des cartes
          renderCards();
        });

        socket.on("bonusPlayed", (data) => {
          if (!gameState.gameData) return;

          // Si le serveur nous a envoyé un nouvel état du jeu, l'utiliser
          if (data.newGameState) {
            gameState.gameData = data.newGameState;
          } else {
            // Sinon, simuler l'application du bonus côté client
            const { playerId, bonusId, targetCharacterId } = data;

            // Récupérer le jeu et le joueur
            const game = gameState.gameData;
            const player = game.players[playerId];

            if (
              player &&
              player.charactersState &&
              player.charactersState[targetCharacterId]
            ) {
              // Trouver la carte de bonus correspondante
              const bonusCard = player.cards.bonus.find(
                (card) => card.id === bonusId
              );
              if (bonusCard) {
                // Appliquer l'effet du bonus (augmentation de l'attaque)
                const characterState =
                  player.charactersState[targetCharacterId];
                const baseAttack =
                  characterState.baseAttack || characterState.currentAttack;
                const bonusPercentage = bonusCard.pourcentagebonus
                  ? parseInt(bonusCard.pourcentagebonus)
                  : 0;

                // Appliquer le bonus: force * (1 + bonus/100)
                characterState.currentAttack = Math.floor(
                  baseAttack * (1 + bonusPercentage / 100)
                );

                // Sauvegarder la valeur d'attaque originale si ce n'est pas déjà fait
                if (!characterState.baseAttack) {
                  characterState.baseAttack = baseAttack;
                }

                // Ajouter le bonus à la liste des bonus actifs
                if (!characterState.activeBonus) {
                  characterState.activeBonus = [];
                }

                // Ajouter les détails du bonus
                characterState.activeBonus.push({
                  bonusId: bonusId,
                  remainingTurns: bonusCard.tourbonus
                    ? parseInt(bonusCard.tourbonus)
                    : 1,
                  percentage: bonusPercentage,
                  name: bonusCard.nomcartebonus || bonusId,
                });
              }
            }
          }

          // Afficher un message avec le nom de la carte si disponible
          const bonusName =
            data.bonusName ||
            gameState.gameData.players[data.playerId]?.cards.bonus.find(
              (c) => c.id === data.bonusId
            )?.nomcartebonus ||
            "Un bonus";

          const targetName =
            data.targetName ||
            gameState.gameData.players[data.playerId]?.cards.personnages.find(
              (c) => c.id === data.targetCharacterId
            )?.nomcarteperso ||
            "un personnage";

          showMessage(`${bonusName} a été joué sur ${targetName}`);

          // Mettre à jour l'affichage
          renderCards();
        });

        socket.on("characterAttacked", (data) => {
          // Mettre à jour l'état du jeu avec les nouvelles valeurs
          if (gameState.gameData && data.newGameState) {
            gameState.gameData = data.newGameState;

            // Si le serveur indique que le tour a changé
            if (data.turnChanged) {
              // Réinitialiser TOUTES les sélections lors du changement de tour
              gameState.selectedCharacter = null;
              gameState.targetCharacter = null;
              gameState.selectedBonus = null;

              gameState.isMyTurn = data.newCurrentTurn === gameState.playerId;

              // Message approprié pour le changement de tour
              if (gameState.isMyTurn) {
                showMessage(
                  "L'adversaire a attaqué. C'est maintenant votre tour!"
                );
              } else {
                showMessage("Vous avez attaqué. Au tour de l'adversaire!");
              }
            }

            // Mettre à jour l'interface
            updateGameStatus();
            updateActionButtons();
            renderCards();

            // Vérifier si la partie est terminée
            checkGameOver();
          }

          // Afficher le message d'attaque
          showMessage(
            `${data.attackerName || "Un personnage"} a attaqué ${
              data.targetName || "un autre personnage"
            } pour ${data.damage || "des"} dégâts!`
          );
        });

        socket.on("playerLeft", (data) => {
          showMessage("L'adversaire s'est déconnecté");
        });

        socket.on("gameOver", (data) => {
          gameState.gameData = data.newGameState;

          // Afficher un message approprié selon la raison de fin de partie
          if (data.reason === "no_attack_turns") {
            if (data.winner === "tie") {
              showMessage(
                "Partie terminée! Match nul - les deux joueurs ont le même nombre de PV restants."
              );
            } else if (data.winner === gameState.playerId) {
              showMessage(
                "Victoire! Vous avez plus de PV restants que votre adversaire."
              );
            } else {
              showMessage("Défaite! Votre adversaire a plus de PV restants.");
            }

            // Afficher les PV totaux
            if (data.playersTotalHealth) {
              for (const pid in data.playersTotalHealth) {
                const playerName = gameState.gameData.players[pid].name;
                const totalHealth = data.playersTotalHealth[pid];
                showMessage(`${playerName}: ${totalHealth} PV restants`);
              }
            }
          }

          // Désactiver les boutons d'action
          gameState.isMyTurn = false;
          updateActionButtons();

          // Mettre à jour l'affichage
          renderCards();
        });

        // Check for existing game in localStorage
        const savedGameId = localStorage.getItem("gameId");
        const savedPlayerId = localStorage.getItem("playerId");
        const savedPlayerName = localStorage.getItem("playerName");

        if (savedGameId && savedPlayerId) {
          const rejoin = confirm(
            "Partie en cours trouvée. Voulez-vous la rejoindre?"
          );
          if (rejoin) {
            gameState.gameId = savedGameId;
            gameState.playerId = savedPlayerId;
            gameState.playerName = savedPlayerName;

            showScreen("waiting");
            document.getElementById("waitingMessage").textContent =
              "Reconnexion en cours...";
            socket.emit("joinRoom", {
              gameId: savedGameId,
              playerId: savedPlayerId,
            });
          } else {
            localStorage.removeItem("gameId");
            localStorage.removeItem("playerId");
            localStorage.removeItem("playerName");
          }
        }

        // Ajouter une fonction pour vérifier si la partie est gagnée/perdue
        function checkGameOver() {
          if (!gameState.gameData) return false;

          const game = gameState.gameData;
          const player = game.players[gameState.playerId];

          // Trouver l'adversaire
          let opponent = null;
          for (const id in game.players) {
            if (id !== gameState.playerId) {
              opponent = game.players[id];
              break;
            }
          }

          if (!player || !opponent) return false;

          // Vérifier si tous les personnages d'un joueur sont à 0 PV
          const playerAlive = Object.values(player.charactersState).some(
            (char) => char.currentHealth > 0
          );
          const opponentAlive = Object.values(opponent.charactersState).some(
            (char) => char.currentHealth > 0
          );

          if (!playerAlive) {
            showMessage(
              "Vous avez perdu la partie ! Tous vos personnages sont vaincus.",
              true
            );
            return true;
          }

          if (!opponentAlive) {
            showMessage(
              "Vous avez gagné la partie ! Tous les personnages adverses sont vaincus."
            );
            return true;
          }

          return false;
        }

        // Fonction pour ajouter la possibilité de zoomer sur les cartes
        function setupCardZoom() {
          // Fonction pour zoomer une carte
          function zoomCard(card) {
            // Créer un overlay de fond
            const overlay = document.createElement("div");
            overlay.className = "overlay-background";
            document.body.appendChild(overlay);

            // Cloner la carte pour l'afficher en grand
            const zoomedCard = card.cloneNode(true);
            zoomedCard.classList.add("card-zoom");
            document.body.appendChild(zoomedCard);

            // Cliquer n'importe où pour fermer
            function closeZoom() {
              document.body.removeChild(overlay);
              document.body.removeChild(zoomedCard);
              document.removeEventListener("click", closeZoom);
            }

            document.addEventListener("click", closeZoom);
          }

          // Écouter les clics longs sur les cartes
          document.addEventListener("mousedown", function (e) {
            // Vérifier si c'est une carte
            let card = null;
            if (e.target.classList.contains("card")) {
              card = e.target;
            } else if (e.target.closest(".card")) {
              card = e.target.closest(".card");
            }

            if (card) {
              const timer = setTimeout(() => {
                zoomCard(card);
              }, 500); // Zoom après 500ms

              // Annuler le zoom si le clic est relâché avant
              const clearTimer = () => {
                clearTimeout(timer);
                document.removeEventListener("mouseup", clearTimer);
              };

              document.addEventListener("mouseup", clearTimer);
            }
          });
        }

        // Appeler cette fonction après le chargement du DOM
        setupCardZoom();

        // Ajouter cette fonction pour déboguer le contenu des cartes
        function debugCardProperties() {
          if (!gameState.gameData) return;

          const game = gameState.gameData;
          const player = game.players[gameState.playerId];

          if (player && player.cards) {
            console.log("Propriétés des cartes personnages:");
            if (
              player.cards.personnages &&
              player.cards.personnages.length > 0
            ) {
              console.table(player.cards.personnages[0]);
            }

            console.log("Propriétés des cartes bonus:");
            if (player.cards.bonus && player.cards.bonus.length > 0) {
              console.table(player.cards.bonus[0]);
            }
          }
        }

        // Ajouter cette fonction pour mieux visualiser les changements de tour
        function showTurnChange(isMyTurn) {
          // Créer un élément de notification de changement de tour
          const notification = document.createElement("div");
          notification.className = "turn-change-notification";
          notification.textContent = isMyTurn
            ? "À VOTRE TOUR"
            : "AU TOUR DE L'ADVERSAIRE";
          notification.style.position = "fixed";
          notification.style.top = "40%";
          notification.style.left = "50%";
          notification.style.transform = "translate(-50%, -50%)";
          notification.style.zIndex = "1000";
          notification.style.padding = "30px 50px";
          notification.style.backgroundColor = isMyTurn
            ? "rgba(76, 175, 80, 0.9)"
            : "rgba(255, 152, 0, 0.9)";
          notification.style.color = "white";
          notification.style.borderRadius = "8px";
          notification.style.fontWeight = "bold";
          notification.style.fontSize = "24px";
          notification.style.boxShadow = "0 4px 20px rgba(0, 0, 0, 0.4)";
          notification.style.transition = "opacity 0.5s";

          document.body.appendChild(notification);

          // Faire disparaître progressivement la notification
          setTimeout(() => {
            notification.style.opacity = "0";
          }, 1500);

          // Supprimer l'élément après l'animation
          setTimeout(() => {
            document.body.removeChild(notification);
          }, 2000);
        }
      });
    </script>
  </body>
</html>
